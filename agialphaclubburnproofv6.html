<!doctype html>
<html>
<head>
  <meta charset="utf-8"/>
  <title>Buyer self‑burn → build proof → recordSelfBurn → claim</title>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <style>
    :root { --fg:#111; --muted:#666; --ok:#0a7a0a; --warn:#b35600; --err:#b00020; --bord:#ddd; --bg:#fafafa; }
    body{font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; margin:24px; max-width:980px; color:var(--fg)}
    h1{font-size:22px; margin:0 0 12px}
    h2{font-size:16px; margin:20px 0 8px}
    label{display:block; margin:8px 0 4px; font-weight:600}
    input,select,textarea,button{width:100%; padding:10px; font-size:14px}
    textarea{height:120px; font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace}
    .row{display:grid; grid-template-columns:1fr 1fr; gap:16px}
    .mono{font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace; word-break: break-all}
    .card{border:1px solid var(--bord); background:#fff; border-radius:10px; padding:14px; margin:12px 0}
    .muted{color:var(--muted)}
    .ok{color:var(--ok); font-weight:600}
    .warn{color:var(--warn); font-weight:600}
    .err{color:var(--err); font-weight:600}
    .btn{background:#111; color:#fff; border-radius:8px; border:none; cursor:pointer}
    .btn:disabled{opacity:.6; cursor:not-allowed}
    .pill{display:inline-block; padding:2px 8px; border-radius:999px; background:#eee; font-size:12px}
    .tiny{font-size:12px}
    .hint{font-size:12px; color:var(--muted)}
    .kbd{font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace; padding:2px 6px; border:1px solid #ccc; border-radius:6px}
  </style>

  <!-- Libraries (reliable UMD builds) -->
  <script src="https://cdn.jsdelivr.net/npm/ethers@5.7.2/dist/ethers.umd.min.js"></script>
  <!-- buffer UMD; exposes window.buffer.Buffer; we promote it to window.Buffer for libs that expect it -->
  <script src="https://cdn.jsdelivr.net/npm/buffer@6.0.3/index.min.js"></script>
  <!-- @ethereumjs/trie UMD; exposes window.ethereumjs_trie.Trie / createProof -->
  <script src="https://cdn.jsdelivr.net/npm/@ethereumjs/trie@5.6.3/dist/index.umd.min.js"></script>
</head>
<body>
  <h1>Buyer self‑burn → build proof → <span class="kbd">recordSelfBurn</span> → claim</h1>

  <!-- Connect -->
  <div class="card">
    <button id="btnConnect" class="btn">Connect MetaMask</button>
    <div class="tiny muted" id="libStatus">libs: …</div>
    <div>Account: <span id="acct" class="mono"></span></div>
    <div>Network: <span id="net" class="mono"></span></div>
  </div>

  <!-- Configure -->
  <div class="card">
    <h2>1) Configure</h2>

    <label>Parent domain (e.g., <i>example.eth</i>)</label>
    <input id="parentDomain" placeholder="example.eth" value="alpha.club.agi.eth">
    <div class="tiny">parentNode (namehash): <span id="parentNode" class="mono"></span></div>

    <label>Label you want to register (e.g., <i>alice</i>)</label>
    <input id="label" placeholder="alice">

    <div class="row">
      <div>
        <label>Registrar (ForeverSubdomainRegistrar)</label>
        <input id="registrar" value="0x75EA7a1E35F8438557Ee1B6682bdFAfBefcD7637">
      </div>
      <div>
        <label>Verifier (BurnReceiptVerifier)</label>
        <input id="verifier" value="0xBcf1065521A7379D6f4AbEF2dEdAf86a77E5eac8">
      </div>
    </div>

    <div class="row">
      <div>
        <label>AGI token address</label>
        <input id="token" value="0xf0780F43b86C13B3d0681B1Cf6DaeB1499e7f14d">
      </div>
      <div>
        <label>Burn to</label>
        <select id="burnTo">
          <option value="burn-prefer">Real burn (try token.burn; fallback 0x…dEaD)</option>
          <option value="dead">0x000000000000000000000000000000000000dEaD</option>
          <option value="zero">0x0000000000000000000000000000000000000000 (may revert)</option>
        </select>
      </div>
    </div>

    <div class="row">
      <div>
        <label>Amount to burn</label>
        <input id="amount" value="250">
        <div class="hint">AGI / decimals 18 (we’ll do ×10¹⁸ automatically)</div>
      </div>
      <div>
        <label>Confirmations required</label>
        <input id="confs" value="6">
      </div>
    </div>

    <div class="row">
      <div>
        <label>RPC URL (optional; leave blank to use MetaMask)</label>
        <input id="rpc" placeholder="https://… (must support eth_getBlockReceipts or receipts)">
      </div>
      <div>
        <label>Burn age / status</label>
        <div id="status" class="pill">–</div>
      </div>
    </div>

    <div class="row">
      <button id="btnBurn" class="btn">Burn 250 AGI</button>
      <a id="aTx" class="btn" target="_blank" style="display:none; text-align:center; text-decoration:none; padding-top:10px">Open burn tx on Etherscan</a>
    </div>

    <label>Burn TX hash (auto‑filled after “Burn now”, or paste manually)</label>
    <input id="txHash" placeholder="0x…" class="mono">
  </div>

  <!-- Build proof -->
  <div class="card">
    <h2>2) Build proof</h2>
    <button id="btnBuild" class="btn">Build header & receipt proof</button>
    <div id="buildMsg" class="tiny mono muted">—</div>

    <div class="row">
      <div>
        <label>blockNumber (uint256)</label>
        <input id="blockNumber" class="mono" readonly>
      </div>
      <div>
        <label>txIndex (uint256)</label>
        <input id="txIndex" class="mono" readonly>
      </div>
    </div>

    <label>headerRlp (bytes)</label>
    <textarea id="headerRlp" readonly></textarea>

    <label>receiptRlp (bytes)</label>
    <textarea id="receiptRlp" readonly></textarea>

    <label>rlpParentNodes (bytes)</label>
    <textarea id="proofNodes" readonly></textarea>

    <div class="hint">These three bytes + <b>buyer</b> (your wallet), <b>parentNode</b>, <b>label</b>, <b>blockNumber</b>, <b>txIndex</b> go into <b>recordSelfBurn</b> on the Verifier.</div>
  </div>

  <!-- Etherscan how-to -->
  <div class="card">
    <h2>3) Call contracts on Etherscan</h2>
    <ol>
      <li>Open <b>BurnReceiptVerifier</b> at <span class="mono">0xBcf1065521A7379D6f4AbEF2dEdAf86a77E5eac8</span> → <b>Contract</b> → <b>Write as Proxy</b>.</li>
      <li>Call <b>recordSelfBurn</b> with:
        <ul>
          <li><b>buyer</b> = your wallet (shown at top)</li>
          <li><b>parentNode</b> = shown in step 1</li>
          <li><b>label</b> = exact label you will register</li>
          <li><b>blockNumber</b>, <b>txIndex</b> = from step 2</li>
          <li><b>headerRlp</b>, <b>receiptRlp</b>, <b>rlpParentNodes</b> = copy from step 2</li>
        </ul>
      </li>
      <li>Then open <b>ForeverSubdomainRegistrar</b> at <span class="mono">0x75EA7a1E35F8438557Ee1B6682bdFAfBefcD7637</span> → <b>Write as Proxy</b> → call <b>claimAfterSelfBurn(name, newOwner, duration)</b>.</li>
    </ol>
  </div>

<script>
(async () => {
  // --- Library readiness ----------------------------------------------------
  const libStatus = document.getElementById('libStatus');
  try {
    // Promote buffer polyfill to global Buffer if needed
    if (!window.Buffer && window.buffer && window.buffer.Buffer) {
      window.Buffer = window.buffer.Buffer;
    }
    const have = {
      ethers: !!window.ethers,
      buffer: !!window.Buffer,
      trie: (window.ethereumjs_trie && window.ethereumjs_trie.Trie)
    };
    const ok = have.ethers && have.buffer && have.trie;
    libStatus.textContent = ok ? 'libs: loaded ✓ (ethers, buffer, trie)' : 'libs: failed to load';
  } catch (e) {
    libStatus.textContent = 'libs: failed to load';
  }

  // --- DOM helpers ----------------------------------------------------------
  const $ = (id) => document.getElementById(id);
  const wait = (ms) => new Promise(r => setTimeout(r, ms));

  // --- State ----------------------------------------------------------------
  let provider, signer, account, chainId, networkName;

  const etherscanBase = (cid) => {
    switch (cid) {
      case 1: return 'https://etherscan.io';
      case 5: return 'https://goerli.etherscan.io';
      case 11155111: return 'https://sepolia.etherscan.io';
      case 17000: return 'https://holesky.etherscan.io';
      default: return 'https://etherscan.io';
    }
  };

  // --- Connect --------------------------------------------------------------
  $('btnConnect').onclick = async () => {
    try {
      if ($('rpc').value.trim()) {
        provider = new ethers.providers.JsonRpcProvider($('rpc').value.trim());
      } else {
        if (!window.ethereum) { alert('Please install MetaMask'); return; }
        await window.ethereum.request({ method: 'eth_requestAccounts' });
        provider = new ethers.providers.Web3Provider(window.ethereum);
      }
      signer = provider.getSigner();
      account = await signer.getAddress();
      const net = await provider.getNetwork();
      chainId = Number(net.chainId);
      networkName = net.name || `chainId ${chainId}`;
      $('acct').textContent = account;
      $('net').textContent = `${networkName} (chainId=${chainId})`;

      // pre-compute parentNode
      computeParentNode();
    } catch (e) {
      alert('Connect failed: ' + (e && e.message || e));
    }
  };

  // --- Namehash (sanitize + ethers.utils.namehash) --------------------------
  function sanitizeEns(name) {
    if (!name) return '';
    let s = name.trim().toLowerCase();
    s = s.replace(/^\.+/, '').replace(/\.+$/, '').replace(/\.\.+/g, '.'); // remove empty components
    return s;
  }
  function computeParentNode() {
    try {
      const n = sanitizeEns($('parentDomain').value);
      $('parentDomain').value = n;
      const node = ethers.utils.namehash(n);
      $('parentNode').textContent = node;
      return node;
    } catch (e) {
      $('parentNode').textContent = '(invalid ENS name)';
      return null;
    }
  }
  $('parentDomain').addEventListener('input', computeParentNode);

  // --- Burn flow ------------------------------------------------------------
  function parseUnitsSafe(val, decimals) {
    const s = (val || '').toString().trim();
    if (!s) throw new Error('Amount required');
    return ethers.utils.parseUnits(s, decimals);
  }

  async function tokenMeta(tokenAddr) {
    const erc20Abi = [
      'function symbol() view returns (string)',
      'function decimals() view returns (uint8)'
    ];
    const token = new ethers.Contract(tokenAddr, erc20Abi, provider);
    const [symbol, decimals] = await Promise.all([
      token.symbol().catch(()=> 'TOKEN'),
      token.decimals().catch(()=> 18)
    ]);
    return { symbol, decimals };
  }

  async function tryCallBurn(tokenAddr, amount) {
    const burnAbi = ['function burn(uint256 amount)'];
    const token = new ethers.Contract(tokenAddr, burnAbi, signer);
    try {
      // Estimate to detect availability
      await token.estimateGas.burn(amount);
      const tx = await token.burn(amount);
      return tx;
    } catch (_) {
      return null; // burn not supported or reverted
    }
  }

  async function burnOrBlackhole() {
    if (!provider || !signer) { alert('Connect MetaMask first'); return; }
    const tokenAddr = $('token').value.trim();
    const { decimals, symbol } = await tokenMeta(tokenAddr);

    // amount: default 250
    const amt = parseUnitsSafe($('amount').value || '250', decimals);

    const choice = $('burnTo').value;
    $('status').textContent = 'Sending burn tx…';

    // Prefer real burn if requested
    if (choice === 'burn-prefer') {
      const burnTx = await tryCallBurn(tokenAddr, amt);
      if (burnTx) {
        afterSent(burnTx);
        return;
      }
      // fallthrough to blackhole burn
    }

    // Prepare ERC20 transfer to chosen burn address
    let target = '0x000000000000000000000000000000000000dEaD';
    if (choice === 'zero') target = '0x0000000000000000000000000000000000000000';

    const erc20Abi = [
      'function transfer(address to, uint256 amount) returns (bool)'
    ];
    const token = new ethers.Contract(tokenAddr, erc20Abi, signer);
    try {
      // gas estimation helps catch “transfer to zero address” upfront
      await token.estimateGas.transfer(target, amt);
      const tx = await token.transfer(target, amt);
      afterSent(tx);
    } catch (e) {
      $('status').textContent = 'Error sending burn: ' + (e && e.message || e);
      throw e;
    }
  }

  function afterSent(tx) {
    const base = etherscanBase(chainId || 1);
    $('txHash').value = tx.hash;
    $('aTx').style.display = 'inline-block';
    $('aTx').href = `${base}/tx/${tx.hash}`;
    $('aTx').textContent = 'Open burn tx on Etherscan';
    watchConfirmations(tx.hash).catch(()=>{});
  }

  $('btnBurn').onclick = () => burnOrBlackhole().catch(console.error);

  // --- Watcher & auto build -------------------------------------------------
  async function watchConfirmations(hash) {
    const needed = parseInt($('confs').value||'6',10);
    while (true) {
      const r = await provider.getTransactionReceipt(hash);
      if (!r || !r.blockNumber) {
        $('status').textContent = 'Pending…';
        await wait(4000); continue;
      }
      const now = await provider.getBlockNumber();
      const c = Math.max(0, now - r.blockNumber);
      if (c >= needed) {
        $('status').className = 'pill ok';
        $('status').textContent = `OK: ${c} confirmations`;
        // Auto-build once
        await buildProofFromTx(hash);
        break;
      } else {
        $('status').className = 'pill';
        $('status').textContent = `Waiting: ${c}/${needed} confirmations`;
        await wait(4000);
      }
    }
  }

  // Manual build button (also auto-called by watcher)
  $('btnBuild').onclick = () => {
    const h = $('txHash').value.trim();
    if (!h) { alert('Paste a burn tx hash first'); return; }
    buildProofFromTx(h).catch(e => {
      console.error(e);
      $('buildMsg').textContent = 'Error: ' + (e && e.message || e);
    });
  };

  // --- Proof building -------------------------------------------------------
  function rlpNum(n) {
    // Minimal big-endian: 0 -> '0x' (empty)
    const bn = ethers.BigNumber.from(n);
    return bn.isZero() ? '0x' : bn.toHexString();
  }
  const toBytes = (hex) => ethers.utils.arrayify(hex || '0x');
  const toHex  = (bytes) => ethers.utils.hexlify(bytes);

  // RLP-encode a typed receipt (EIP-2718)
  function encodeReceiptTyped(rc) {
    // payload: [status, cumulativeGasUsed, logsBloom, logs]
    const statusOrRoot = (rc.status !== undefined && rc.status !== null)
      ? rlpNum(rc.status) : rc.root; // Byzantium vs legacy
    const logs = (rc.logs || []).map(log => [
      log.address,
      (log.topics||[]).map(t => t),
      (log.data||'0x')
    ]);
    const payload = ethers.utils.RLP.encode([
      statusOrRoot,
      rlpNum(rc.cumulativeGasUsed),
      rc.logsBloom || '0x',
      logs
    ]);
    const t = (rc.type === 0 || rc.type === '0x0' || rc.type === undefined) ? null : rc.type;
    if (!t) return payload; // legacy byte-for-byte
    // Concatenate type byte + RLP payload
    const typeByte = ethers.utils.hexlify(typeof t === 'string' ? t : Number(t));
    return ethers.utils.hexConcat([ typeByte, payload ]);
  }

  // RLP-encode execution block header (PoS aware)
  function encodeHeaderRlp(b) {
    const fields = [
      b.parentHash, b.sha3Uncles, b.miner, b.stateRoot, b.transactionsRoot, b.receiptsRoot,
      b.logsBloom, rlpNum(b.difficulty || 0), rlpNum(b.number), rlpNum(b.gasLimit),
      rlpNum(b.gasUsed), rlpNum(b.timestamp), b.extraData, b.mixHash || b.prevRandao || '0x',
      b.nonce || '0x0000000000000000'
    ];
    if (b.baseFeePerGas) fields.push(rlpNum(b.baseFeePerGas));
    if (b.withdrawalsRoot) fields.push(b.withdrawalsRoot);
    if (b.blobGasUsed) fields.push(rlpNum(b.blobGasUsed));
    if (b.excessBlobGas) fields.push(rlpNum(b.excessBlobGas));
    if (b.parentBeaconBlockRoot) fields.push(b.parentBeaconBlockRoot);
    return ethers.utils.RLP.encode(fields);
  }

  async function getBlockAndReceipts(blockNumberHex) {
    const block = await provider.send('eth_getBlockByNumber', [blockNumberHex, true]);
    let receipts = null;
    try {
      receipts = await provider.send('eth_getBlockReceipts', [blockNumberHex]);
    } catch (_) {}
    if (!receipts) {
      receipts = [];
      for (const tx of block.transactions) {
        const r = await provider.getTransactionReceipt(tx.hash);
        receipts.push(r);
      }
    }
    return { block, receipts };
  }

  async function buildProofFromTx(txHash) {
    $('buildMsg').textContent = 'Loading receipt…';
    const rc = await provider.getTransactionReceipt(txHash);
    if (!rc || !rc.blockNumber) throw new Error('Receipt not found / still pending');

    const blockNumber = rc.blockNumber;
    $('blockNumber').value = String(blockNumber);
    $('txIndex').value = String(rc.transactionIndex);

    const needed = parseInt($('confs').value||'6',10);
    const now = await provider.getBlockNumber();
    const confs = Math.max(0, now - blockNumber);
    if (confs < needed) throw new Error(`Not enough confirmations yet (${confs}/${needed})`);
    if (confs > 256) throw new Error('Too old for blockhash (must be ≤ 256 blocks)');

    $('buildMsg').textContent = 'Downloading block + receipts & building trie…';

    const { block, receipts } = await getBlockAndReceipts(ethers.utils.hexValue(blockNumber));

    // Header RLP + sanity check
    const headerRlp = encodeHeaderRlp(block);
    const headerHash = ethers.utils.keccak256(headerRlp);
    if (headerHash.toLowerCase() !== block.hash.toLowerCase()) {
      throw new Error('Header RLP does not hash to block.hash (RPC mismatch).');
    }

    // Build receipts trie
    const { Trie, createProof } = window.ethereumjs_trie;
    const trie = new Trie(); // in-memory
    for (const r of receipts) {
      const key = ethers.utils.RLP.encode(ethers.BigNumber.from(r.transactionIndex).toHexString());
      const valHex = encodeReceiptTyped(r);           // hex string
      await trie.put(Buffer.from(ethers.utils.arrayify(key)),
                     Buffer.from(ethers.utils.arrayify(valHex)));
    }
    const rootHex = '0x' + Buffer.from(trie.root()).toString('hex');
    if (rootHex.toLowerCase() !== block.receiptsRoot.toLowerCase()) {
      throw new Error('Reconstructed receiptsRoot does not match block.receiptsRoot');
    }

    // Proof for our txIndex
    const idxKey = ethers.utils.RLP.encode(ethers.BigNumber.from(rc.transactionIndex).toHexString());
    const proofArr = await createProof(trie, Buffer.from(ethers.utils.arrayify(idxKey))); // Buffer[]
    const proofRlp = ethers.utils.RLP.encode(proofArr.map(buf => ethers.utils.hexlify(buf)));

    // Encoded receipt (typed)
    const receiptRlp = encodeReceiptTyped(rc);

    // Fill outputs
    $('headerRlp').value  = ethers.utils.hexlify(ethers.utils.arrayify(headerRlp));
    $('receiptRlp').value = ethers.utils.hexlify(ethers.utils.arrayify(receiptRlp));
    $('proofNodes').value = ethers.utils.hexlify(ethers.utils.arrayify(proofRlp));

    $('buildMsg').textContent = 'Proof ready ✓ Paste these values into recordSelfBurn on Etherscan.';
  }

  // Update parentNode right away for convenience
  computeParentNode();

})();
</script>
</body>
</html>

