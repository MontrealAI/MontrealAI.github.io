<!doctype html>
<html>
<head>
  <meta charset="utf-8"/>
  <title>Buyer self‑burn → build proof → recordSelfBurn → claim</title>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <style>
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; margin: 24px; max-width: 980px }
    h1 { font-size: 20px; margin: 0 0 8px }
    h2 { font-size: 16px; margin-top: 24px }
    label { display:block; margin: 8px 0 4px; font-weight:600 }
    input, select, textarea, button { width: 100%; padding: 10px; font-size: 14px; border-radius: 6px; border: 1px solid #d0d0d0; }
    textarea { height: 120px; font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace }
    .row { display: grid; grid-template-columns: 1fr 1fr; gap: 16px; }
    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; word-break: break-all }
    .ok { color: #0a7a0a; font-weight: 600 }
    .warn { color: #b35600; font-weight: 600 }
    .err { color: #b00020; font-weight: 600 }
    small { color:#555 }
    .card { border: 1px solid #ddd; padding: 12px; border-radius: 8px; margin: 12px 0; }
    .btn { background:#111; color:#fff; border:none; cursor:pointer; }
    .btn:disabled { opacity:.55; cursor:not-allowed; }
    ol { margin: 8px 0 0 18px; padding:0; }
  </style>

  <!-- Ethers (you can self-host too, but CDN is fine) -->
  <script src="https://cdn.jsdelivr.net/npm/ethers@5.7.2/dist/ethers.umd.min.js"></script>

  <!-- Self-hosted libs: place these files alongside this HTML -->
  <script>window.global = window; /* some UMD builds expect 'global' */</script>
  <script src="./buffer.min.js"></script>
  <script>
    // Make sure Buffer is globally visible (works for both buffer.min.js variants)
    if (!window.Buffer && window.buffer && window.buffer.Buffer) window.Buffer = window.buffer.Buffer;
  </script>
  <script src="./rlp.umd.js"></script>
  <script src="./trie.umd.js"></script>
</head>

<body>
  <h1>Buyer self‑burn → build proof → <code>recordSelfBurn</code> → claim</h1>

  <div class="card">
    <button id="btnConnect" class="btn">Connect MetaMask</button>
    <div>Account: <span id="acct" class="mono"></span></div>
    <div>Network: <span id="net" class="mono"></span></div>
    <div>Libs: <span id="libs" class="mono warn">checking…</span></div>
  </div>

  <div class="card">
    <h2>1) Configure</h2>

    <label>Parent domain (e.g., <i>example.eth</i>)</label>
    <input id="parentDomain" placeholder="alpha.club.agi.eth" value="alpha.club.agi.eth">
    <div>parentNode (namehash): <span id="parentNode" class="mono"></span></div>

    <label>Label you want to register (e.g., <i>alice</i>)</label>
    <input id="label" placeholder="alice" value="3">

    <div class="row">
      <div>
        <label>Registrar (ForeverSubdomainRegistrar)</label>
        <input id="registrar" value="0x75EA7a1E35F8438557Ee1B6682bdFAfBefcD7637">
      </div>
      <div>
        <label>Verifier (BurnReceiptVerifier)</label>
        <input id="verifier" value="0xBcf1065521A7379D6f4AbEF2dEdAf86a77E5eac8">
      </div>
    </div>

    <div class="row">
      <div>
        <label>AGI token address</label>
        <!-- lowercase is fine; we’ll normalize to checksum -->
        <input id="tokenAddr" value="0xf0780f43b86c13b3d0681b1cf6daeb1499e7f14d" />
        <small>Address may be pasted lower‑case; we’ll normalize to checksum automatically.</small>
      </div>
      <div>
        <label>Burn to</label>
        <select id="burnMode">
          <option value="burn">Real burn (call token.burn)</option>
          <option value="dead">Fallback: transfer to 0x…dEaD (recommended if burn() not supported)</option>
        </select>
        <small>If the token lacks <code>burn(uint256)</code>, we’ll use <code>transfer(0x…dEaD, amount)</code>.</small>
      </div>
    </div>

    <div class="row">
      <div>
        <label>Amount to burn</label>
        <input id="amount" value="250">
        <small>We’ll multiply by the token’s decimals (auto‑detected; fallback 18).</small>
      </div>
      <div>
        <label>Confirmations required</label>
        <input id="confs" value="6">
      </div>
    </div>

    <div class="row">
      <div>
        <label>RPC URL (optional; leave blank to use MetaMask)</label>
        <input id="rpc" placeholder="(must support eth_getBlockByNumber & receipts)">
      </div>
      <div>
        <label>Burn age / status</label>
        <div id="status" class="mono">–</div>
      </div>
    </div>

    <div class="row">
      <button id="btnBurn" class="btn">Burn 250 AGI</button>
      <a id="btnOpenTx" class="btn" href="#" target="_blank" style="text-align:center; line-height:38px; text-decoration:none;">Open burn tx on Etherscan</a>
    </div>

    <label>Burn TX hash (auto‑filled after “Burn now”, or paste manually)</label>
    <input id="txHash" placeholder="0x… (transaction hash)">
  </div>

  <div class="card">
    <h2>2) Build proof</h2>
    <div class="row">
      <button id="btnBuild" class="btn">Build header &amp; receipt proof</button>
      <label style="display:flex; align-items:center; gap:8px;">
        <input id="autoBuild" type="checkbox" checked>
        Auto‑build when ready
      </label>
    </div>
    <div id="buildMsg" class="mono warn">—</div>

    <div class="row">
      <div>
        <label>blockNumber (uint256)</label>
        <input id="blockNumber" class="mono" readonly>
      </div>
      <div>
        <label>txIndex (uint256)</label>
        <input id="txIndex" class="mono" readonly>
      </div>
    </div>

    <label>headerRlp (bytes)</label>
    <textarea id="headerRlp" readonly></textarea>

    <label>receiptRlp (bytes)</label>
    <textarea id="receiptRlp" readonly></textarea>

    <label>rlpParentNodes (bytes)</label>
    <textarea id="proofNodes" readonly></textarea>

    <small>Copy these three bytes values, and use with <b>buyer</b> (your wallet), <b>parentNode</b>, <b>label</b>, <b>blockNumber</b>, <b>txIndex</b> in <code>recordSelfBurn</code> (BurnReceiptVerifier).</small>
  </div>

<script>
(async () => {
  // ---------- helpers ----------
  const $ = id => document.getElementById(id);

  // libs detection (Buffer + RLP + Trie)
  function libsReady() {
    const okBuf  = !!(window.Buffer && typeof window.Buffer.from === 'function');
    const okRLP  = !!(window.rlp && window.rlp.RLP);
    const trieNs = window.ethereumjs || window.ethereumjs_trie || {};
    const okTrie = !!(trieNs.Trie || (trieNs.default && trieNs.default.Trie));
    return { okBuf, okRLP, okTrie };
  }
  (function showLibsStatus(){
    const { okBuf, okRLP, okTrie } = libsReady();
    if (okBuf && okRLP && okTrie) { $('libs').textContent = 'OK'; $('libs').className='mono ok'; }
    else {
      const miss = [];
      if (!okBuf) miss.push('Buffer');
      if (!okRLP) miss.push('RLP');
      if (!okTrie) miss.push('Trie');
      $('libs').textContent = 'failed to load ('+miss.join(', ')+')';
      $('libs').className='mono err';
    }
  })();

  // provider / signer
  let provider, signer, acct, chain;
  $('btnConnect').onclick = async () => {
    try {
      if ($('rpc').value.trim()) {
        provider = new ethers.providers.JsonRpcProvider($('rpc').value.trim());
      } else {
        if (!window.ethereum) return alert('Please install MetaMask');
        await window.ethereum.request({ method: 'eth_requestAccounts' });
        provider = new ethers.providers.Web3Provider(window.ethereum);
      }
      signer = provider.getSigner();
      acct = await signer.getAddress().catch(()=>null);
      const net = await provider.getNetwork();
      chain = net.chainId;
      $('acct').textContent = acct || '(read‑only)';
      $('net').textContent = `${net.name} (chainId=${net.chainId})`;
      updateParentNode();
    } catch (e) {
      alert('Failed to connect: ' + (e && e.message || e));
    }
  };

  // ENS namehash (EIP‑137) using ethers utils
  function namehash(name) {
    if (!name) return ethers.constants.HashZero;
    let node = ethers.constants.HashZero;
    const labels = name.split('.').reverse();
    for (const label of labels) {
      const labelHash = ethers.utils.keccak256(ethers.utils.toUtf8Bytes(label));
      node = ethers.utils.keccak256(ethers.utils.concat([
        ethers.utils.arrayify(node),
        ethers.utils.arrayify(labelHash)
      ]));
    }
    return node;
  }
  function updateParentNode() {
    try {
      $('parentNode').textContent = namehash($('parentDomain').value.trim());
    } catch { $('parentNode').textContent = '—'; }
  }
  $('parentDomain').addEventListener('input', updateParentNode);

  // Normalize any address to a valid checksum (accepts lower‑case, mixed, etc.)
  function normAddrMaybe(a) {
    const s = (a || '').trim();
    if (!s) throw new Error('Missing address');
    return ethers.utils.getAddress(s.toLowerCase());
  }

  // minimal hex/bytes helpers for RLP + Trie
  const toBuf = (hex) => Buffer.from((hex || '0x').slice(2).padStart(((hex||'0x').length-2 + ( ((hex||'0x').length-2)%2 ?1:0)), '0'), 'hex');
  const qToBuf = (hex) => { // hex quantity -> minimal big‑endian
    if (!hex || hex === '0x' || hex === '0x0') return Buffer.from([]);
    let s = hex.slice(2); if (s.length % 2) s = '0' + s; return Buffer.from(s, 'hex');
  };
  function rlpEncodeUint(n) {
    const bn = ethers.BigNumber.from(n);
    const hex = bn.toHexString();
    const body = hex === '0x00' ? '' : hex.slice(2).replace(/^0+/, '');
    return window.rlp.RLP.encode(Buffer.from(body, 'hex'));
  }

  function rlpEncodeReceiptPayload(r) {
    // Receipt payload: [status|root, cumulativeGasUsed, logsBloom, logs]
    const statusOrRoot = r.status ? qToBuf(ethers.utils.hexlify(r.status)) : toBuf(r.root);
    const cgu = qToBuf(r.cumulativeGasUsed);
    const bloom = toBuf(r.logsBloom);
    const logs = r.logs.map(log => [ toBuf(log.address), log.topics.map(toBuf), toBuf(log.data) ]);
    return window.rlp.RLP.encode([ statusOrRoot, cgu, bloom, logs ]);
  }
  function rlpEncodeTypedReceipt(r) {
    const payload = rlpEncodeReceiptPayload(r);
    const typeHex = (r.type && r.type !== '0x' && r.type !== '0x0') ? r.type : null;
    if (typeHex) {
      const t = parseInt(typeHex, 16);
      return Buffer.concat([ Buffer.from([t]), payload ]);
    }
    return payload; // legacy-style
  }
  function rlpEncodeHeader(block) {
    const fields = [];
    fields.push(toBuf(block.parentHash));
    fields.push(toBuf(block.sha3Uncles));
    fields.push(toBuf(block.miner));
    fields.push(toBuf(block.stateRoot));
    fields.push(toBuf(block.transactionsRoot));
    fields.push(toBuf(block.receiptsRoot));
    fields.push(toBuf(block.logsBloom));
    fields.push(qToBuf(block.difficulty));        // 0 in PoS
    fields.push(qToBuf(block.number));
    fields.push(qToBuf(block.gasLimit));
    fields.push(qToBuf(block.gasUsed));
    fields.push(qToBuf(block.timestamp));
    fields.push(toBuf(block.extraData));
    fields.push(toBuf(block.mixHash));            // prevRandao in PoS
    fields.push(toBuf(block.nonce));              // 0x0000000000000000 in PoS
    if (block.baseFeePerGas)        fields.push(qToBuf(block.baseFeePerGas));
    if (block.withdrawalsRoot)      fields.push(toBuf(block.withdrawalsRoot));
    if (block.blobGasUsed)          fields.push(qToBuf(block.blobGasUsed));
    if (block.excessBlobGas)        fields.push(qToBuf(block.excessBlobGas));
    if (block.parentBeaconBlockRoot)fields.push(toBuf(block.parentBeaconBlockRoot));
    return window.rlp.RLP.encode(fields);
  }

  async function getBlockAndAllReceipts(blockNumberHex) {
    const block = await provider.send('eth_getBlockByNumber', [blockNumberHex, true]);
    let receipts = null;
    try { receipts = await provider.send('eth_getBlockReceipts', [blockNumberHex]); } catch (_) {}
    if (!receipts) {
      receipts = [];
      for (const tx of block.transactions) {
        const r = await provider.getTransactionReceipt(tx.hash);
        receipts.push(r);
      }
    }
    return { block, receipts };
  }

  // ---------- burn flow ----------
  const ERC20_ABI = [
    'function decimals() view returns (uint8)',
    'function burn(uint256) returns ()',
    'function transfer(address to, uint256 amount) returns (bool)'
  ];

  let lastTxHash = null, burnWatcherOn = false;

  $('btnBurn').onclick = async () => {
    try {
      if (!provider) return alert('Please Connect MetaMask first.');
      const tokenAddr = normAddrMaybe($('tokenAddr').value);
      const token = new ethers.Contract(tokenAddr, ERC20_ABI, signer);

      // decimals (fallback to 18 if the call fails)
      let decimals = 18;
      try { decimals = await token.decimals(); } catch (_) {}
      const human = $('amount').value.trim() || '0';
      const amount = ethers.utils.parseUnits(human, decimals);

      // try burn first
      const mode = $('burnMode').value; // 'burn' or 'dead'
      let tx;
      if (mode === 'burn') {
        let supportsBurn = false;
        try { await token.callStatic.burn(amount); supportsBurn = true; } catch (_) {}
        if (supportsBurn) {
          tx = await token.burn(amount);
        } else {
          // fallback to 0x...dEaD
          tx = await token.transfer('0x000000000000000000000000000000000000dEaD', amount);
        }
      } else {
        tx = await token.transfer('0x000000000000000000000000000000000000dEaD', amount);
      }

      lastTxHash = tx.hash;
      $('txHash').value = tx.hash;
      $('btnOpenTx').href = `https://etherscan.io/tx/${tx.hash}`;
      $('btnOpenTx').textContent = 'Open burn tx on Etherscan';

      // start monitoring confirmations
      watchConfirmations(tx.hash);
    } catch (e) {
      alert((e && e.message) || e);
    }
  };

  async function watchConfirmations(txHash) {
    const required = parseInt($('confs').value || '6', 10);
    if (burnWatcherOn) return;
    burnWatcherOn = true;

    const update = async () => {
      try {
        const r = await provider.getTransactionReceipt(txHash);
        if (!r || !r.blockNumber) { $('status').textContent = 'Pending…'; return; }
        const now = await provider.getBlockNumber();
        const confs = Math.max(0, now - r.blockNumber);
        $('status').textContent = (confs >= required) ? `OK: ${confs} confirmations` : `Waiting: ${confs}/${required} confirmations`;

        if (confs >= required) {
          provider.off('block', onBlock);
          burnWatcherOn = false;
          if ($('autoBuild').checked) buildProofFromTx(txHash).catch(e => {
            $('buildMsg').textContent = 'Error: ' + ((e && e.message) || e);
            $('buildMsg').className = 'mono err';
          });
        }
      } catch (e) {
        $('status').textContent = 'Error: ' + (e && e.message || e);
      }
    };
    const onBlock = async (_n) => update();
    provider.on('block', onBlock);
    update();
  }

  // ---------- proof builder ----------
  async function buildProofFromTx(txHash) {
    $('buildMsg').textContent = 'Fetching block + receipts…';
    $('buildMsg').className = 'mono warn';

    const r = await provider.getTransactionReceipt(txHash);
    if (!r || !r.blockNumber) throw new Error('Receipt not found / pending');

    const now = await provider.getBlockNumber();
    const confsRequired = parseInt($('confs').value || '6', 10);
    const confs = now - r.blockNumber;
    if (confs < confsRequired) throw new Error('Not enough confirmations yet');
    if (confs > 256) throw new Error('Too old for blockhash (must be ≤ 256 blocks)');

    $('blockNumber').value = String(r.blockNumber);
    $('txIndex').value = String(r.transactionIndex);

    const { block, receipts } = await getBlockAndAllReceipts(ethers.utils.hexValue(r.blockNumber));
    // header RLP sanity check
    const headerRlp = rlpEncodeHeader(block);
    const headerHash = ethers.utils.keccak256(headerRlp);
    if (headerHash.toLowerCase() !== block.hash.toLowerCase()) {
      throw new Error('Header RLP does not hash to block.hash (RPC mismatch).');
    }

    // build receipts trie
    const trieNs = window.ethereumjs || window.ethereumjs_trie || {};
    const TrieCtor = trieNs.Trie || (trieNs.default && trieNs.default.Trie);
    const createProof = trieNs.createProof || (TrieCtor && TrieCtor.createProof && TrieCtor.createProof.bind(TrieCtor));
    if (!TrieCtor || !createProof) throw new Error('Trie library missing or incompatible');

    const trie = new TrieCtor(); // in-memory
    for (const rc of receipts) {
      const key = rlpEncodeUint(parseInt(rc.transactionIndex));
      const val = rlpEncodeTypedReceipt(rc);
      await trie.put(key, val);
    }
    const rootHex = '0x' + Buffer.from(trie.root()).toString('hex');
    if (rootHex.toLowerCase() !== block.receiptsRoot.toLowerCase()) {
      throw new Error('Reconstructed receiptsRoot does not match block.receiptsRoot');
    }

    // proof for our txIndex
    const key = rlpEncodeUint(parseInt(r.transactionIndex));
    const proofArr = await createProof(trie, key); // array of node Buffers
    const proofRlp = window.rlp.RLP.encode(proofArr);
    const receiptRlp = rlpEncodeTypedReceipt(r);

    $('headerRlp').value  = '0x' + Buffer.from(headerRlp).toString('hex');
    $('receiptRlp').value = '0x' + Buffer.from(receiptRlp).toString('hex');
    $('proofNodes').value = '0x' + Buffer.from(proofRlp).toString('hex');

    $('buildMsg').textContent = 'Proof ready. Paste into recordSelfBurn on Etherscan.';
    $('buildMsg').className = 'mono ok';
  }

  $('btnBuild').onclick = () => {
    const txh = $('txHash').value.trim();
    if (!txh) { alert('Please paste or create a burn tx first'); return; }
    buildProofFromTx(txh).catch(e => {
      $('buildMsg').textContent = 'Error: ' + (e && e.message || e);
      $('buildMsg').className = 'mono err';
    });
  };

  // init parentNode if user hasn’t connected yet
  updateParentNode();
})();
</script>
</body>
</html>

