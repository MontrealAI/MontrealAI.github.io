<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <title>Buyer self-burn → build proof → recordSelfBurn → claim</title>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>

  <style>
    :root{--bg:#fff;--fg:#111;--muted:#6b7280;--ok:#0a7a0a;--warn:#b35600;--err:#b00020;--bd:#e5e7eb}
    body{font-family:system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,Cantarell,sans-serif;background:var(--bg);color:var(--fg);margin:24px;max-width:980px}
    h1{font-size:20px;margin:0 0 12px}
    h2{font-size:16px;margin:18px 0 8px}
    .card{border:1px solid var(--bd);border-radius:10px;padding:14px;margin:14px 0}
    label{display:block;margin:10px 0 6px;font-weight:600}
    input,select,textarea,button{width:100%;padding:10px;border:1px solid var(--bd);border-radius:8px;font-size:14px;background:#fff}
    textarea{height:130px;font-family:ui-monospace,SFMono-Regular,Menlo,Consolas,monospace}
    .row{display:grid;grid-template-columns:1fr 1fr;gap:14px}
    .mono{font-family:ui-monospace,SFMono-Regular,Menlo,Consolas,monospace;word-break:break-all}
    .btn{background:#111;color:#fff;border:none;border-radius:8px;cursor:pointer;font-weight:600}
    .btn:disabled{opacity:.55;cursor:not-allowed}
    .inline{display:flex;gap:12px;align-items:center;flex-wrap:wrap}
    .ok{color:var(--ok);font-weight:700}
    .warn{color:var(--warn);font-weight:700}
    .err{color:var(--err);font-weight:700}
    small{color:var(--muted)}
  </style>

  <!-- Self-hosted libraries (order matters) -->
  <script src="libs/ethers-5.7.2.umd.min.js"></script>

  <script src="libs/buffer-6.0.3.bundle.js"></script>
  <script>
    // expose Node-style Buffer for libs that expect it
    window.Buffer = window.Buffer || (window.buffer && window.buffer.Buffer);
  </script>

  <script src="libs/rlp-4.0.1.iife.js"></script>         <!-- window.RLP -->
  <script src="libs/trie-6.2.1.iife.js"></script>        <!-- window.EthereumjsTrie -->
</head>
<body>
  <h1>Buyer self-burn → build proof → <b>recordSelfBurn</b> → claim</h1>

  <div class="card">
    <div class="inline">
      <button id="btnConnect" class="btn" style="flex:1">Connect MetaMask</button>
      <span id="libsStatus" class="warn mono">libs: loading…</span>
    </div>
    <div>Account: <span id="acct" class="mono"></span></div>
    <div>Network: <span id="net" class="mono"></span></div>
  </div>

  <div class="card">
    <h2>1) Configure</h2>

    <label>Parent domain (e.g., <i>example.eth</i>)</label>
    <input id="parentDomain" placeholder="alpha.club.agi.eth" value="alpha.club.agi.eth"/>
    <div>parentNode (namehash): <span id="parentNode" class="mono"></span></div>

    <label>Label you want to register (e.g., <i>alice</i>)</label>
    <input id="label" value="3"/>

    <div class="row">
      <div>
        <label>Registrar (ForeverSubdomainRegistrar)</label>
        <input id="registrar" value="0x75EA7a1E35F8438557Ee1B6682bdFAfBefcD7637"/>
      </div>
      <div>
        <label>Verifier (BurnReceiptVerifier)</label>
        <input id="verifier" value="0xBcf1065521A7379D6f4AbEF2dEdAf86a77E5eac8"/>
      </div>
    </div>

    <div class="row">
      <div>
        <label>AGI token address</label>
        <input id="token" value="0xf0780F43b86C13b3D0681B1cF6DaeB1499e7F14D"/>
        <small>Any case is fine; we normalize to checksum.</small>
      </div>
      <div>
        <label>Burn to</label>
        <select id="burnMode">
          <option value="burn">Real burn (call token.burn)</option>
          <option value="dead">Transfer to 0x0000…dEaD (fallback)</option>
        </select>
        <small>If the token lacks <code>burn(uint256)</code>, fallback uses <code>transfer(0x…dEaD, amount)</code>.</small>
      </div>
    </div>

    <div class="row">
      <div>
        <label>Amount to burn</label>
        <input id="amount" value="250"/>
        <small>We auto-scale by the token’s <b>decimals()</b> (fallback 18).</small>
      </div>
      <div>
        <label>Confirmations required</label>
        <input id="confs" value="6"/>
      </div>
    </div>

    <div class="row">
      <div>
        <label>RPC URL (optional; blank → MetaMask)</label>
        <input id="rpc" placeholder="(try Infura/Alchemy mainnet for consistency)"/>
      </div>
      <div>
        <label>Burn age / status</label>
        <div id="status" class="mono">–</div>
      </div>
    </div>

    <div class="row">
      <button id="btnBurn" class="btn">Burn 250 AGI</button>
      <a id="btnOpenTx" class="btn" style="text-align:center;text-decoration:none" target="_blank" rel="noopener">Open burn tx on Etherscan</a>
    </div>

    <label>Burn TX hash (auto-filled after “Burn now”, or paste manually)</label>
    <input id="txHash" class="mono" placeholder="0x… (transaction hash)"/>
  </div>

  <div class="card">
    <h2>2) Build proof</h2>
    <div class="inline" style="justify-content:space-between">
      <button id="btnBuild" class="btn">Build header & receipt proof</button>
      <label class="inline"><input type="checkbox" id="autoBuild" checked style="width:auto;margin-right:8px">Auto-build when ready</label>
    </div>
    <div id="buildMsg" class="mono warn" style="margin-top:8px">—</div>

    <div class="row" style="margin-top:8px">
      <div>
        <label>blockNumber (uint256)</label>
        <input id="blockNumber" class="mono" readonly/>
      </div>
      <div>
        <label>txIndex (uint256)</label>
        <input id="txIndex" class="mono" readonly/>
      </div>
    </div>

    <label>headerRlp (bytes)</label>
    <textarea id="headerRlp" class="mono" readonly></textarea>

    <label>receiptRlp (bytes)</label>
    <textarea id="receiptRlp" class="mono" readonly></textarea>

    <label>rlpParentNodes (bytes)</label>
    <textarea id="proofNodes" class="mono" readonly></textarea>

    <small>Paste these three bytes + <b>buyer</b> (your wallet), <b>parentNode</b>, <b>label</b>, <b>blockNumber</b>, <b>txIndex</b> into <b>recordSelfBurn</b> on the Verifier (Etherscan → Contract → Write as Proxy).</small>
  </div>

<script>
(function(){
  // ========= lib presence check =========
  const libsOk = !!(window.ethers && window.Buffer && window.RLP && window.EthereumjsTrie);
  const libsEl = document.getElementById('libsStatus');
  libsEl.textContent = libsOk ? 'libs: loaded ✓' : 'libs: failed to load';
  libsEl.className   = libsOk ? 'ok mono' : 'err mono';
  if (!libsOk) return;

  // ========= DOM helpers =========
  const $ = id => document.getElementById(id);
  const RLP = window.RLP;
  const TrieNS = window.EthereumjsTrie || window.ethereumjs_trie || window.Trie;
  const TrieClass = TrieNS.Trie || TrieNS;
  const createProof = TrieNS.createProof || TrieClass.createProof;

  // ========= provider / signer =========
  let provider, signer, account, chain;

  async function chooseProvider(){
    const url = $('rpc').value.trim();
    if (url) return new ethers.providers.JsonRpcProvider(url);
    if (!window.ethereum) throw new Error('MetaMask not found');
    return new ethers.providers.Web3Provider(window.ethereum);
  }

  async function connect(){
    provider = await chooseProvider();
    if (provider.send) try { await provider.send('eth_requestAccounts', []); } catch {}
    signer   = provider.getSigner();
    account  = await signer.getAddress().catch(()=>null);
    chain    = await provider.getNetwork();
    $('acct').textContent = account || '(read-only)';
    $('net').textContent  = `${chain.name} (chainId=${chain.chainId})`;
  }

  $('btnConnect').onclick = () => connect().catch(e => alert(e.message||e));

  // ========= namehash (EIP-137) =========
  function computeParentNode(){
    try {
      const node = ethers.utils.namehash(($('parentDomain').value||'').trim());
      $('parentNode').textContent = node;
      return node;
    } catch { $('parentNode').textContent='—'; return null; }
  }
  $('parentDomain').addEventListener('input', computeParentNode);
  computeParentNode();

  // ========= address normalize =========
  const normAddr = s => ethers.utils.getAddress(String(s).trim().toLowerCase());

  // ========= burn =========
  const ERC20_ABI = [
    'function decimals() view returns (uint8)',
    'function burn(uint256 amount) returns (bool)',
    'function transfer(address to, uint256 amount) returns (bool)'
  ];

  async function burnNow(){
    if (!signer) await connect();
    const tokenAddr = normAddr($('token').value);
    const mode = $('burnMode').value; // 'burn' | 'dead'
    const token = new ethers.Contract(tokenAddr, ERC20_ABI, signer);

    let dec = 18;
    try { dec = await token.decimals(); } catch {}
    const amt = ethers.utils.parseUnits(($('amount').value||'250').trim(), dec);

    let tx;
    if (mode === 'burn'){
      try { tx = await token.burn(amt); }
      catch { tx = await token.transfer('0x000000000000000000000000000000000000dEaD', amt); }
    } else {
      tx = await token.transfer('0x000000000000000000000000000000000000dEaD', amt);
    }

    $('txHash').value = tx.hash;
    $('btnOpenTx').href = `https://etherscan.io/tx/${tx.hash}`;
    $('btnOpenTx').textContent = 'Open burn tx on Etherscan';
    await watchConfirmations(tx.hash);
  }
  $('btnBurn').onclick = () => burnNow().catch(e => alert(e.message || e));

  async function watchConfirmations(hash){
    provider = provider || await chooseProvider();
    const need = parseInt($('confs').value||'6',10);
    let r;
    while (true){
      r = await provider.getTransactionReceipt(hash);
      if (!r || !r.blockNumber) { $('status').textContent = 'Pending…'; await new Promise(r=>setTimeout(r,3500)); continue; }
      const now = await provider.getBlockNumber();
      const confs = Math.max(0, now - r.blockNumber);
      $('status').textContent = confs >= need ? `OK: ${confs} confirmations` : `Waiting: ${confs}/${need} confirmations`;
      $('blockNumber').value = String(r.blockNumber);
      $('txIndex').value     = String(r.transactionIndex);
      if (confs >= need){ if ($('autoBuild').checked) await buildProofFromTx(hash); break; }
      await new Promise(r=>setTimeout(r,3500));
    }
  }

  // ========= RLP helpers (strict, canonical) =========
  // canonical bytes for "bytes" fields
  const b = (hex) => ethers.utils.arrayify(hex || '0x'); // Uint8Array
  // canonical bytes for "quantity"/int fields: 0 -> empty
  const q = (hexQty) => {
    if (hexQty === null || hexQty === undefined) return new Uint8Array([]);
    const h = ethers.utils.hexValue(hexQty);
    return (h === '0x0' || h === '0x') ? new Uint8Array([]) : ethers.utils.arrayify(h);
  };
  const rlpU = (n) => RLP.encode(ethers.utils.arrayify(ethers.utils.hexlify(n) || '0x'));

  function rlpEncodeHeader(block){
    const F = [];
    // 15 fixed fields
    F.push(b(block.parentHash));
    F.push(b(block.sha3Uncles));
    F.push(b(block.miner));          // beneficiary/coinbase
    F.push(b(block.stateRoot));
    F.push(b(block.transactionsRoot));
    F.push(b(block.receiptsRoot));
    F.push(b(block.logsBloom));
    F.push(q(block.difficulty));
    F.push(q(block.number));
    F.push(q(block.gasLimit));
    F.push(q(block.gasUsed));
    F.push(q(block.timestamp));
    F.push(b(block.extraData));
    // Merge field: prefer prevRandao
    const randao = (block.prevRandao ?? block.mixHash);
    F.push(b(randao));
    // PoS nonce still included
    F.push(b(block.nonce));
    // include fork fields if present (not null/undefined), even if "0x0"
    const present = v => v !== null && v !== undefined;
    if (present(block.baseFeePerGas))          F.push(q(block.baseFeePerGas));          // London
    if (present(block.withdrawalsRoot))        F.push(b(block.withdrawalsRoot));        // Shanghai
    if (present(block.blobGasUsed))            F.push(q(block.blobGasUsed));            // Cancun
    if (present(block.excessBlobGas))          F.push(q(block.excessBlobGas));          // Cancun
    if (present(block.parentBeaconBlockRoot))  F.push(b(block.parentBeaconBlockRoot));  // Cancun
    return RLP.encode(F);
  }

  function rlpEncodeReceiptPayload(r){
    const statusOrRoot = (r.status !== null && r.status !== undefined) ? q(ethers.utils.hexlify(r.status)) : b(r.root);
    const logs = r.logs.map(log => [ b(log.address), log.topics.map(b), b(log.data) ]);
    return RLP.encode([ statusOrRoot, q(r.cumulativeGasUsed), b(r.logsBloom), logs ]);
  }
  function rlpEncodeTypedReceipt(r){
    const payload = rlpEncodeReceiptPayload(r);
    const tHex    = (r.type && r.type !== '0x' && r.type !== '0x0') ? r.type : null;
    return tHex ? ethers.utils.concat([ new Uint8Array([parseInt(tHex,16)]), payload ]) : payload;
  }

  // ========= block + receipts fetch (fast path only for custom RPC) =========
  async function getBlockAndReceipts(blockNumberHex){
    const block = await provider.send('eth_getBlockByNumber', [blockNumberHex, true]);
    let receipts = null;
    if ($('rpc').value.trim()){ // try fast path only when user supplied RPC
      try { receipts = await provider.send('eth_getBlockReceipts', [blockNumberHex]); } catch {}
    }
    if (!receipts){
      receipts = [];
      for (const tx of block.transactions){
        receipts.push(await provider.getTransactionReceipt(tx.hash));
      }
    }
    return { block, receipts };
  }

  async function buildProofFromTx(txHash){
    try{
      provider = provider || await chooseProvider();
      const r = await provider.getTransactionReceipt(txHash);
      if (!r || !r.blockNumber) throw new Error('Receipt not found / pending');

      $('blockNumber').value = String(r.blockNumber);
      $('txIndex').value     = String(r.transactionIndex);

      $('buildMsg').textContent = 'Downloading block + receipts and building trie…';
      const { block, receipts } = await getBlockAndReceipts(ethers.utils.hexValue(r.blockNumber));

      const headerRlp = rlpEncodeHeader(block);
      const hashGot   = ethers.utils.keccak256(headerRlp).toLowerCase();
      const hashExp   = String(block.hash).toLowerCase();
      if (hashGot !== hashExp){
        $('buildMsg').textContent = 'Error: Header RLP does not hash to block.hash (RPC mismatch).';
        $('buildMsg').className   = 'mono err';
        return;
      }

      // receipts trie
      const trie = new TrieClass();
      for (const rc of receipts) {
        const key = rlpU(parseInt(rc.transactionIndex));
        const val = rlpEncodeTypedReceipt(rc);
        await trie.put(key, val);
      }
      const rootHex = '0x' + Buffer.from(trie.root()).toString('hex');
      if (rootHex.toLowerCase() !== String(block.receiptsRoot).toLowerCase()){
        $('buildMsg').textContent = 'Error: Reconstructed receiptsRoot does not match block.receiptsRoot';
        $('buildMsg').className   = 'mono err';
        return;
      }

      // proof for our txIndex
      const key      = rlpU(parseInt(r.transactionIndex));
      const nodes    = await (createProof ? createProof(trie, key) : TrieClass.createProof(trie, key));
      const proofRlp = RLP.encode(nodes);
      const receiptRlp = rlpEncodeTypedReceipt(r);

      $('headerRlp').value  = '0x' + Buffer.from(headerRlp).toString('hex');
      $('receiptRlp').value = '0x' + Buffer.from(receiptRlp).toString('hex');
      $('proofNodes').value = '0x' + Buffer.from(proofRlp).toString('hex');

      $('buildMsg').textContent = 'Proof ready.';
      $('buildMsg').className   = 'mono ok';
    }catch(e){
      $('buildMsg').textContent = 'Error: ' + (e?.message || e);
      $('buildMsg').className   = 'mono err';
    }
  }

  $('btnBuild').onclick = () => {
    const h = $('txHash').value.trim();
    if (!h){ $('buildMsg').textContent = 'Enter/paste a burn tx hash first.'; $('buildMsg').className='mono err'; return; }
    buildProofFromTx(h);
  };

  // init
  $('btnOpenTx').textContent = 'Open burn tx on Etherscan';
  $('btnOpenTx').href = 'https://etherscan.io/';
})();
</script>
</body>
</html>

