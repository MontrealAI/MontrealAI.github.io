<!doctype html>
<html>
<head>
  <meta charset="utf-8"/>
  <title>Burn → Proof → recordSelfBurn helper</title>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <style>
    :root {
      --fg:#111; --muted:#555; --ok:#0a7a0a; --warn:#b35600; --err:#b00020; --line:#e5e5e5; --bg:#fff; --chip:#f4f6f8;
      --accent:#1b6ef3;
    }
    * { box-sizing: border-box }
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; margin: 24px; max-width: 980px; color: var(--fg); background:var(--bg) }
    h1 { font-size: 20px; margin: 0 0 6px }
    h2 { font-size: 16px; margin: 18px 0 10px }
    p, li { line-height: 1.45 }
    label { display:block; margin: 10px 0 6px; font-weight:600 }
    input, select, textarea, button { width: 100%; padding: 10px; font-size: 14px; border:1px solid var(--line); border-radius:8px; background:#fff }
    input[readonly], textarea[readonly] { background:#fafafa }
    textarea { height: 120px; font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace }
    .row { display:grid; gap:16px }
    @media (min-width:800px){ .row.two { grid-template-columns: 1fr 1fr } .row.three { grid-template-columns: 1fr 1fr 1fr } }
    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; word-break: break-all }
    .card { border:1px solid var(--line); padding:14px; border-radius:12px; margin:14px 0 }
    .chip { display:inline-block; padding:4px 8px; border-radius:999px; background:var(--chip); font-size:12px; }
    .ok { color: var(--ok); font-weight:600 }
    .warn { color: var(--warn); font-weight:600 }
    .err { color: var(--err); font-weight:600 }
    small { color: var(--muted) }
    .btn { background: var(--accent); color:#fff; border:0; cursor:pointer }
    .btn:disabled { opacity: .6; cursor:not-allowed }
    .btn-secondary { background:#fff; color:var(--accent); border:1px solid var(--accent) }
    .toolbar { display:flex; gap:10px; flex-wrap:wrap; margin:8px 0 }
    .list { padding-left:18px }
    .kvs { display:flex; flex-wrap:wrap; gap:8px; margin:8px 0 }
    .kv { background:var(--chip); border-radius:8px; padding:6px 8px; }
    .kv b { font-weight:600 }
    .right { text-align:right }
    .hint { font-size:12px; color:var(--muted); margin-top:6px }
    .copy { margin-top:6px }
  </style>

  <!-- Ethers / helpers -->
  <script src="https://cdn.jsdelivr.net/npm/ethers@5.7.2/dist/ethers.umd.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/buffer@6.0.3/index.min.js"></script>
  <script>window.Buffer = buffer.Buffer;</script>
  <script src="https://cdn.jsdelivr.net/npm/rlp@3.0.0/dist/rlp.umd.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@ethereumjs/util@9.0.1/dist/index.umd.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@ethereumjs/trie@5.6.3/dist/index.umd.js"></script>
</head>
<body>
  <h1>Burn → Build Proof → recordSelfBurn → Claim</h1>
  <p class="hint">This page helps you prove you burned AGI on Ethereum and then claim a subdomain. It does not hold keys or send transactions — it only prepares the proof bytes you paste on Etherscan.</p>

  <!-- Step 0: Connect -->
  <div class="card">
    <h2>Step 0 — Connect wallet</h2>
    <div class="toolbar">
      <button id="btnConnect" class="btn">Connect MetaMask</button>
      <button id="btnDisconnect" class="btn btn-secondary" disabled>Disconnect</button>
    </div>
    <div class="kvs">
      <span class="kv">Account: <span id="acct" class="mono"></span></span>
      <span class="kv">Network: <span id="net" class="mono"></span></span>
      <span class="kv">Status: <span id="wstatus" class="mono">Not connected</span></span>
    </div>
    <small>Tip: Use Ethereum Mainnet. You can optionally provide a custom RPC below if your provider is slow.</small>
  </div>

  <!-- Step 1: Configure -->
  <div class="card">
    <h2>Step 1 — Configure</h2>
    <div class="row two">
      <div>
        <label>Parent domain (e.g. <i>example.eth</i>)</label>
        <input id="parentDomain" placeholder="example.eth" />
        <div class="hint">We’ll compute the <b>parentNode</b> (namehash) automatically.</div>
      </div>
      <div>
        <label>Label you want (e.g. <i>alice</i>)</label>
        <input id="label" placeholder="alice" />
      </div>
    </div>

    <div class="row two">
      <div>
        <label>AGI token address</label>
        <input id="token" value="0xf0780f43b86c13b3d0681b1cf6daeb1499e7f14d" />
        <div class="hint">Default is the AGI token you shared.</div>
      </div>
      <div>
        <label>Amount to burn (tokens)</label>
        <input id="amountTokens" value="250" />
        <div class="hint">We auto‑read token <code>decimals()</code> to compute the raw value for Etherscan.</div>
      </div>
    </div>

    <div class="row two">
      <div>
        <label>Optional RPC URL (for faster reads)</label>
        <input id="rpc" placeholder="(blank = use MetaMask’s RPC)" />
      </div>
      <div>
        <label>Confirmations required</label>
        <input id="confs" value="6" />
      </div>
    </div>

    <div class="kvs">
      <span class="kv">parentNode: <span id="parentNode" class="mono"></span></span>
      <span class="kv">token decimals: <span id="tokenDecs" class="mono"></span></span>
      <span class="kv">raw burn value: <span id="rawValue" class="mono"></span></span>
    </div>

    <div class="toolbar">
      <button id="btnPrepBurn" class="btn">Prepare burn details</button>
      <a id="lnkTokenWrite" class="btn btn-secondary" target="_blank" rel="noopener">Open AGI token on Etherscan (Write)</a>
    </div>

    <div class="hint">
      On Etherscan, go to <b>Write Contract</b> → connect wallet → call <b>transfer</b> with:
      <ul class="list">
        <li><b>to</b>: <code class="mono">0x000000000000000000000000000000000000dEaD</code> (burn address)</li>
        <li><b>value</b>: <span id="valForTransfer" class="mono"></span> (paste this exact integer)</li>
      </ul>
    </div>
  </div>

  <!-- Step 2: Paste burn TX -->
  <div class="card">
    <h2>Step 2 — Paste your burn transaction hash</h2>
    <label>Burn TX hash</label>
    <input id="txHash" placeholder="0x…" />
    <div class="toolbar">
      <button id="btnCheckBurn" class="btn">Check burn & confirmations</button>
    </div>
    <div id="burnCheck" class="mono"></div>
    <div class="kvs">
      <span class="kv">Burn status: <span id="status" class="mono"></span></span>
      <span class="kv">Block #: <span id="blockNumberChip" class="mono"></span></span>
      <span class="kv">Tx index: <span id="txIndexChip" class="mono"></span></span>
    </div>
  </div>

  <!-- Step 3: Build proof -->
  <div class="card">
    <h2>Step 3 — Build proof (header & receipt)</h2>
    <div class="toolbar">
      <button id="btnBuild" class="btn" disabled>Build header & receipt proof</button>
      <button id="btnCopyAll" class="btn btn-secondary" disabled>Copy all fields</button>
      <button id="btnDownload" class="btn btn-secondary" disabled>Download JSON</button>
    </div>
    <div id="buildMsg" class="mono"></div>

    <div class="row two">
      <div>
        <label>blockNumber (uint256)</label>
        <input id="blockNumber" class="mono" readonly>
      </div>
      <div>
        <label>txIndex (uint256)</label>
        <input id="txIndex" class="mono" readonly>
      </div>
    </div>

    <label>headerRlp (bytes)</label>
    <textarea id="headerRlp" readonly></textarea>
    <div class="right"><button class="btn btn-secondary copy" data-copy="headerRlp">Copy headerRlp</button></div>

    <label>receiptRlp (bytes)</label>
    <textarea id="receiptRlp" readonly></textarea>
    <div class="right"><button class="btn btn-secondary copy" data-copy="receiptRlp">Copy receiptRlp</button></div>

    <label>rlpParentNodes (bytes)</label>
    <textarea id="proofNodes" readonly></textarea>
    <div class="right"><button class="btn btn-secondary copy" data-copy="proofNodes">Copy rlpParentNodes</button></div>

    <small>Paste these three <b>bytes</b> values + <b>buyer</b> + <b>parentNode</b> + <b>label</b> + <b>blockNumber</b> + <b>txIndex</b> into <b>recordSelfBurn</b> on Etherscan.</small>
  </div>

  <!-- Step 4: Call on Etherscan -->
  <div class="card">
    <h2>Step 4 — Call the contracts on Etherscan</h2>
    <ol class="list">
      <li>
        Open <b>BurnReceiptVerifier</b> → <i>Write as Proxy</i>:
        <div class="toolbar">
          <a class="btn btn-secondary" target="_blank" rel="noopener"
             href="https://etherscan.io/address/0xbCf1065521A7379D6f4AbEF2dEdAf86a77E5eac8#writeProxyContract">Open Verifier (Write)</a>
        </div>
        Call <b>recordSelfBurn(buyer,parentNode,label,blockNumber,txIndex,headerRlp,receiptRlp,rlpParentNodes)</b>.
        <div class="hint">Buyer = your wallet address; label = what you typed above (e.g. “alice”).</div>
      </li>
      <li>
        Then open <b>ForeverSubdomainRegistrar</b> → <i>Write as Proxy</i> and call
        <b>claimAfterSelfBurn(name, newOwner, duration)</b>.
        <div class="toolbar">
          <a class="btn btn-secondary" target="_blank" rel="noopener"
             href="https://etherscan.io/address/0x75ea7a1e35f8438557ee1b6682bdfafbefcd7637#writeProxyContract">Open Registrar (Write)</a>
        </div>
        <div class="hint">
          <b>name</b> is “label.parent”, e.g. <code class="mono" id="exampleName">alice.example.eth</code> ·
          <b>newOwner</b> = your wallet · <b>duration</b> = how long (in seconds, e.g. 31536000 for ~1 year).
        </div>
      </li>
    </ol>
  </div>

<script>
(async () => {
  // ——— libs ———
  const { RLP } = window.rlp;
  const { Trie, createProof } = window.ethereumjs_trie;
  const { hexToBytes } = window.ethereumjs_util;

  // ——— DOM helpers ———
  const $  = (id) => document.getElementById(id);
  const set = (id, v) => { const el=$(id); if (!el) return; if ('value' in el) el.value=v; else el.textContent=v; };
  const toast = (msg, cls='') => { $('buildMsg').textContent = msg; $('buildMsg').className = 'mono ' + cls; };

  // ——— constants ———
  const DEAD = '0x000000000000000000000000000000000000dEaD';
  const ZERO = '0x0000000000000000000000000000000000000000';
  const TRANSFER_TOPIC = '0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef';

  // ——— state ———
  let provider, signer, acct, chainId, tokenDecimals=18, cachedReceipt=null;

  // ——— connect/disconnect ———
  $('btnConnect').onclick = async () => {
    try {
      const rpc = $('rpc').value.trim();
      if (rpc) {
        provider = new ethers.providers.JsonRpcProvider(rpc);
      } else {
        if (!window.ethereum) return alert('Please install MetaMask.');
        await window.ethereum.request({ method: 'eth_requestAccounts' });
        provider = new ethers.providers.Web3Provider(window.ethereum);
      }
      signer = provider.getSigner();
      acct = await signer.getAddress().catch(() => null);
      const net = await provider.getNetwork();
      chainId = Number(net.chainId);
      set('acct', acct || '(read-only)');
      set('net', `${net.name || 'mainnet'} (chainId ${chainId})`);
      set('wstatus', chainId === 1 ? 'Connected (Mainnet)' : 'Connected (NOT mainnet)');
      $('btnDisconnect').disabled = false;
    } catch (e) {
      set('wstatus', 'Failed to connect'); console.error(e);
    }
  };
  $('btnDisconnect').onclick = () => {
    provider = signer = null; acct = chainId = undefined;
    set('acct',''); set('net',''); set('wstatus','Not connected');
    $('btnDisconnect').disabled = true;
  };

  // ——— utils ———
  function namehash(name) {
    // EIP‑137 namehash
    let node = '0x' + '00'.repeat(32);
    if (!name) return node;
    const labels = name.split('.').reverse();
    for (const label of labels) {
      const labelHash = ethers.utils.keccak256(ethers.utils.toUtf8Bytes(label));
      node = ethers.utils.keccak256(ethers.utils.concat([node, labelHash]));
    }
    return node;
  }
  const toBuf = (hex) => Buffer.from((hex || '0x').slice(2).padStart(((hex||'0x').length-2 + (((hex||'0x').length-2)%2?1:0)), '0'), 'hex');
  const qToBuf = (hex) => {
    if (!hex || hex === '0x' || hex === '0x0') return Buffer.from([]);
    let s = hex.slice(2); if (s.length % 2) s = '0' + s; return Buffer.from(s, 'hex');
  };
  function rlpEncodeReceiptPayload(r) {
    const statusOrRoot = r.status ? qToBuf(r.status) : toBuf(r.root);
    const logs = r.logs.map(log => [ toBuf(log.address), log.topics.map(toBuf), toBuf(log.data) ]);
    return RLP.encode([ statusOrRoot, qToBuf(r.cumulativeGasUsed), toBuf(r.logsBloom), logs ]);
  }
  function rlpEncodeTypedReceipt(r) {
    const payload = rlpEncodeReceiptPayload(r);
    const typeHex = (r.type && r.type !== '0x' && r.type !== '0x0') ? r.type : null;
    if (typeHex) return Buffer.concat([ Buffer.from([parseInt(typeHex,16)]), payload ]);
    return payload;
  }
  function rlpEncodeHeader(block) {
    const f=[]; // order matters
    const maybe = (v, to=qToBuf) => (v!==undefined && v!==null) ? to(v) : undefined;
    const push = (x) => { if (x!==undefined) f.push(x); };
    push(toBuf(block.parentHash)); push(toBuf(block.sha3Uncles)); push(toBuf(block.miner));
    push(toBuf(block.stateRoot)); push(toBuf(block.transactionsRoot)); push(toBuf(block.receiptsRoot));
    push(toBuf(block.logsBloom)); push(maybe(block.difficulty)); push(maybe(block.number));
    push(maybe(block.gasLimit)); push(maybe(block.gasUsed)); push(maybe(block.timestamp));
    push(toBuf(block.extraData)); push(toBuf(block.mixHash)); push(toBuf(block.nonce));
    push(maybe(block.baseFeePerGas)); push(block.withdrawalsRoot ? toBuf(block.withdrawalsRoot) : undefined);
    push(maybe(block.blobGasUsed)); push(maybe(block.excessBlobGas));
    push(block.parentBeaconBlockRoot ? toBuf(block.parentBeaconBlockRoot) : undefined);
    return RLP.encode(f);
  }
  function rlpEncodeUint(n) {
    return RLP.encode(Buffer.from(ethers.utils.stripZeros(ethers.utils.hexlify(n)).slice(2) || '', 'hex'));
  }
  function copy(text) {
    return navigator.clipboard.writeText(text).then(() => toast('Copied to clipboard', 'ok'));
  }

  // ——— UI bindings ———
  $('btnPrepBurn').onclick = async () => {
    try {
      const parent = $('parentDomain').value.trim();
      if (!parent) return alert('Enter the parent domain (e.g. example.eth).');
      const pnode = namehash(parent);
      set('parentNode', pnode);
      set('exampleName', `${($('label').value || 'alice').trim()}.${parent}`);

      const token = $('token').value.trim();
      const erc20 = new ethers.Contract(token, [
        "function decimals() view returns (uint8)"
      ], provider || new ethers.providers.InfuraProvider('homestead'));
      tokenDecimals = await erc20.decimals().catch(()=>18);
      set('tokenDecs', String(tokenDecimals));

      const amount = $('amountTokens').value.trim();
      const raw = ethers.utils.parseUnits(amount || '0', tokenDecimals).toString();
      set('rawValue', raw);
      set('valForTransfer', raw);

      const tokenWrite = `https://etherscan.io/address/${token}#writeContract`;
      $('lnkTokenWrite').href = tokenWrite;
      toast('Burn details prepared. Click the Etherscan link and use transfer(to=dead, value=raw).', 'ok');
    } catch (e) {
      console.error(e); toast('Failed to fetch token decimals. You can still continue if you know the raw value.', 'warn');
    }
  };

  async function getBlockAndAllReceipts(blockNumberHex) {
    const block = await (provider).send('eth_getBlockByNumber', [blockNumberHex, true]);
    let receipts=null;
    try { receipts = await provider.send('eth_getBlockReceipts', [blockNumberHex]); } catch(_) {}
    if (!receipts) {
      receipts = [];
      for (const tx of block.transactions) receipts.push(await provider.getTransactionReceipt(tx.hash));
    }
    return { block, receipts };
  }

  $('btnCheckBurn').onclick = async () => {
    try {
      if (!provider) return alert('Connect your wallet first.');
      const txHash = $('txHash').value.trim();
      if (!txHash) return alert('Paste the burn transaction hash.');
      const token = $('token').value.trim();
      const expectedValue = $('rawValue').textContent || $('rawValue').value;

      const r = await provider.getTransactionReceipt(txHash);
      if (!r || !r.blockNumber) throw new Error('Receipt not found yet — is the TX confirmed?');

      // Find ERC‑20 Transfer(buyer -> DEAD/ZERO, value) from the token
      const okLog = (r.logs || []).find(l =>
        l.address.toLowerCase() === token.toLowerCase() &&
        l.topics && l.topics[0] === TRANSFER_TOPIC &&
        [DEAD.toLowerCase(), ZERO.toLowerCase()].includes(('0x'+l.topics[2].slice(26)).toLowerCase())
      );

      // Extract buyer/from address (topic[1]) and amount (data)
      let buyer = '(unknown)', amt = '(unknown)';
      if (okLog) {
        buyer = '0x' + okLog.topics[1].slice(26);
        try { amt = ethers.BigNumber.from(okLog.data).toString(); } catch {}
      }

      // Status line
      const now = await provider.getBlockNumber();
      const confs = now - r.blockNumber;
      const need = parseInt(($('confs').value || '6'), 10);

      const basicOk = !!okLog && (acct ? buyer.toLowerCase() === acct.toLowerCase() : true);
      const valueOk = (!!okLog && expectedValue && amt === expectedValue);

      const lines = [
        `Token match: ${r.logs.some(l=>l.address.toLowerCase()===token.toLowerCase()) ? 'YES' : 'NO'}`,
        `Transfer -> burn address: ${okLog ? 'YES' : 'NO'}`,
        `Buyer (from): ${buyer}`,
        `Amount (raw): ${amt}`,
        `Matches expected amount: ${valueOk ? 'YES' : 'NO'}`,
        `Confirmations: ${confs}/${need}`
      ];
      $('burnCheck').textContent = lines.join('\n');

      set('status', confs >= need ? `OK: ${confs} confirmations` : `Waiting: ${confs}/${need}`);
      set('blockNumberChip', String(r.blockNumber));
      set('txIndexChip', String(r.transactionIndex));
      set('blockNumber', String(r.blockNumber));
      set('txIndex', String(r.transactionIndex));

      if (!okLog) throw new Error('Could not find a Transfer to the burn address for the AGI token in this TX.');
      if (confs < need) throw new Error('Not enough confirmations yet.');
      if (now - r.blockNumber > 256) throw new Error('Block too old (>256) for on-chain blockhash check.');

      cachedReceipt = r;
      $('btnBuild').disabled = false;
      toast('Burn looks good. You can now build the proof.', 'ok');
    } catch (e) {
      console.error(e); toast(`Error: ${e && e.message || e}`, 'err');
    }
  };

  function buildProofFrom(block, receipts, r) {
    // header
    const headerRlp = rlpEncodeHeader(block);
    const headerHash = ethers.utils.keccak256(headerRlp);
    if (headerHash.toLowerCase() !== (block.hash||'').toLowerCase()) {
      throw new Error('Header RLP does not hash to block.hash (RPC mismatch).');
    }
    // trie
    const trie = new Trie();
    return (async () => {
      for (const rc of receipts) {
        const key = rlpEncodeUint(parseInt(rc.transactionIndex));
        const val = rlpEncodeTypedReceipt(rc);
        await trie.put(key, val);
      }
      const rootHex = '0x' + Buffer.from(trie.root()).toString('hex');
      if (rootHex.toLowerCase() !== block.receiptsRoot.toLowerCase()) {
        throw new Error('Reconstructed receiptsRoot does not match block.receiptsRoot.');
      }
      const key = rlpEncodeUint(parseInt(r.transactionIndex));
      const proofArr = await createProof(trie, key);
      return {
        headerRlp: '0x'+Buffer.from(headerRlp).toString('hex'),
        receiptRlp: '0x'+Buffer.from(rlpEncodeTypedReceipt(r)).toString('hex'),
        proofNodes: '0x'+Buffer.from(RLP.encode(proofArr)).toString('hex')
      };
    })();
  }

  $('btnBuild').onclick = async () => {
    try {
      if (!cachedReceipt) return alert('First run “Check burn & confirmations”.');
      $('btnBuild').disabled = true;
      toast('Downloading block + receipts and building trie… this can take a moment.', '');

      const { blockNumber } = cachedReceipt;
      const { block, receipts } = await getBlockAndAllReceipts(ethers.utils.hexValue(blockNumber));
      const out = await buildProofFrom(block, receipts, cachedReceipt);

      set('headerRlp', out.headerRlp);
      set('receiptRlp', out.receiptRlp);
      set('proofNodes', out.proofNodes);

      $('btnCopyAll').disabled = false;
      $('btnDownload').disabled = false;
      toast('Proof ready. Copy the values into recordSelfBurn on Etherscan.', 'ok');
    } catch (e) {
      console.error(e); toast(`Error: ${e && e.message || e}`, 'err');
    } finally {
      $('btnBuild').disabled = false;
    }
  };

  // copy one
  for (const btn of document.querySelectorAll('.copy')) {
    btn.addEventListener('click', () => copy($(btn.dataset.copy).value));
  }
  // copy all
  $('btnCopyAll').onclick = () => {
    const parentNode = $('parentNode').textContent.trim();
    const payload = {
      buyer: acct || '(your wallet address)',
      parentNode,
      label: $('label').value.trim(),
      blockNumber: $('blockNumber').value,
      txIndex: $('txIndex').value,
      headerRlp: $('headerRlp').value,
      receiptRlp: $('receiptRlp').value,
      rlpParentNodes: $('proofNodes').value
    };
    copy(JSON.stringify(payload, null, 2));
  };
  // download JSON
  $('btnDownload').onclick = () => {
    const data = {
      buyer: acct || '',
      parentNode: $('parentNode').textContent.trim(),
      label: $('label').value.trim(),
      blockNumber: $('blockNumber').value,
      txIndex: $('txIndex').value,
      headerRlp: $('headerRlp').value,
      receiptRlp: $('receiptRlp').value,
      rlpParentNodes: $('proofNodes').value
    };
    const blob = new Blob([JSON.stringify(data, null, 2)], {type:'application/json'});
    const a = document.createElement('a');
    a.href = URL.createObjectURL(blob);
    a.download = 'recordSelfBurn-input.json';
    a.click();
    URL.revokeObjectURL(a.href);
  };

  // live compute parentNode & example name
  $('parentDomain').addEventListener('input', () => {
    const parent = $('parentDomain').value.trim();
    set('parentNode', parent ? namehash(parent) : '');
    set('exampleName', `${($('label').value || 'alice').trim()}.${parent||'example.eth'}`);
  });
  $('label').addEventListener('input', () => {
    const parent = $('parentDomain').value.trim() || 'example.eth';
    set('exampleName', `${($('label').value || 'alice').trim()}.${parent}`);
  });

})();
</script>
</body>
</html>

