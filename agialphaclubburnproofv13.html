<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <title>Buyer self‑burn → build proof → recordSelfBurn → claim</title>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>

  <!-- Local, self-hosted vendor libs (must exist in ./vendor) -->
  <script src="./vendor/ethers-5.7.2.umd.min.js"></script>
  <script src="./vendor/buffer-6.0.3.min.js"></script>
  <script src="./vendor/rlp-3.0.0.umd.js"></script>
  <script src="./vendor/ethereumjs-trie-5.6.3.umd.js"></script>

  <style>
    :root {
      --bg:#0b0b0c; --panel:#151517; --border:#2a2a2d; --muted:#a4a4aa;
      --text:#e8e8ee; --accent:#7ddc88; --warn:#ffb86b; --err:#ff6b7a;
    }
    * { box-sizing: border-box; }
    html,body { margin:0; padding:0; background:var(--bg); color:var(--text); font:14px/1.45 system-ui, -apple-system, Segoe UI, Roboto, sans-serif; }
    .wrap { max-width: 980px; margin: 24px auto; padding: 0 16px; }
    h1 { font-size: 18px; margin: 0 0 12px; }
    h2 { font-size: 16px; margin: 18px 0 10px; }
    .row { display: grid; gap: 12px; grid-template-columns: 1fr 1fr; }
    .card { background:var(--panel); border:1px solid var(--border); border-radius:10px; padding:14px; margin:12px 0; }
    label { display:block; margin: 8px 0 4px; color: var(--muted); }
    input, select, textarea, button {
      width: 100%; padding:10px 12px; border-radius:8px; border:1px solid var(--border);
      background:#0f0f11; color:var(--text); font-size:14px;
    }
    textarea { height: 140px; font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace; }
    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace; word-break: break-all; }
    .btn { background:#1c1c20; cursor:pointer; border:1px solid #2a2a2d; font-weight:600; }
    .btn:hover { filter: brightness(1.08); }
    .btn-primary { background:#1e2f20; border-color:#274a2b; }
    .btn-dark { background:#151517; }
    .status { font-weight:600; }
    .ok { color: var(--accent); }
    .warn { color: var(--warn); }
    .err { color: var(--err); }
    small { color: var(--muted); }
    .topbar { display:flex; gap:12px; align-items:center; }
    .pill { padding:6px 10px; border:1px solid var(--border); border-radius:999px; background:#101012; }
    .right { margin-left:auto; }
    .muted { color:var(--muted); }
  </style>
</head>
<body>
<div class="wrap">

  <div class="topbar">
    <h1>Buyer self‑burn → build proof → <span class="mono">recordSelfBurn</span> → claim</h1>
    <span id="libsStatus" class="pill err">libs: failed to load</span>
    <div class="right pill mono" id="acctBox">Account: —</div>
    <div class="pill mono" id="netBox">Network: —</div>
  </div>

  <div class="card">
    <button class="btn btn-primary" id="btnConnect">Connect MetaMask</button>
  </div>

  <div class="card">
    <h2>1) Configure</h2>

    <label>Parent domain (e.g., <i>example.eth</i>)</label>
    <input id="parentDomain" placeholder="example.eth" value="alpha.club.agi.eth"/>

    <label>parentNode (namehash)</label>
    <input id="parentNode" class="mono" readonly placeholder="—"/>

    <label>Label you want to register (e.g., <i>alice</i>)</label>
    <input id="label" placeholder="alice" value="3"/>

    <div class="row">
      <div>
        <label>Registrar (ForeverSubdomainRegistrar)</label>
        <input id="registrar" class="mono" value="0x75EA7a1E35F8438557Ee1B6682bdFAfBefcD7637"/>
      </div>
      <div>
        <label>Verifier (BurnReceiptVerifier)</label>
        <input id="verifier" class="mono" value="0xBcf1065521A7379D6f4AbEF2dEdAf86a77E5eac8"/>
      </div>
    </div>

    <div class="row">
      <div>
        <label>AGI token address</label>
        <input id="token" class="mono" value="0xf0780F43b86C13B3d0681B1Cf6DaeB1499e7f14d"/>
        <small>Address may be pasted any case; we’ll normalize to a checksummed address.</small>
      </div>
      <div>
        <label>Burn to</label>
        <select id="burnMode">
          <option value="burn">Real burn (call token.burn)</option>
          <option value="zero">0x0000…0000 (recommended if token lacks burn)</option>
        </select>
        <small>If the token lacks <span class="mono">burn(uint256)</span>, fallback uses <span class="mono">transfer(0x0000…0000, amount)</span>.</small>
      </div>
    </div>

    <div class="row">
      <div>
        <label>Amount to burn</label>
        <input id="amount" value="250"/><small>AGI / decimals auto‑detected (fallback 18).</small>
      </div>
      <div>
        <label>Confirmations required</label>
        <input id="confs" value="6"/>
      </div>
    </div>

    <div class="row">
      <div>
        <label>RPC URL (optional; blank → MetaMask)</label>
        <input id="rpc" placeholder="(must support eth_getBlockByNumber & receipts)"/>
      </div>
      <div>
        <label>Burn age / status</label>
        <div id="age" class="status mono">—</div>
      </div>
    </div>

    <div class="row">
      <button class="btn btn-primary" id="btnBurn">Burn 250 AGI</button>
      <button class="btn btn-dark" id="btnOpenTx">Open burn tx on Etherscan</button>
    </div>

    <label>Burn TX hash (auto‑filled after “Burn now”, or paste manually)</label>
    <input id="txHash" class="mono" placeholder="0x… (transaction hash)"/>
  </div>

  <div class="card">
    <h2>2) Build proof</h2>
    <div class="row" style="align-items:center">
      <button class="btn btn-primary" id="btnBuild">Build header & receipt proof</button>
      <label style="display:flex; align-items:center; gap:8px;">
        <input type="checkbox" id="autoBuild" checked/> Auto‑build when ready
      </label>
    </div>
    <div id="buildMsg" class="mono muted" style="margin:8px 0;">—</div>
    <div class="row">
      <div>
        <label>blockNumber (uint256)</label>
        <input id="blockNumber" class="mono" readonly/>
      </div>
      <div>
        <label>txIndex (uint256)</label>
        <input id="txIndex" class="mono" readonly/>
      </div>
    </div>

    <label>headerRlp (bytes)</label>
    <textarea id="headerRlp" class="mono" readonly></textarea>

    <label>receiptRlp (bytes)</label>
    <textarea id="receiptRlp" class="mono" readonly></textarea>

    <label>rlpParentNodes (bytes)</label>
    <textarea id="proofNodes" class="mono" readonly></textarea>

    <small>Copy these three bytes and use with <b>buyer</b> (your wallet), <b>parentNode</b>, <b>label</b>, <b>blockNumber</b>, <b>txIndex</b> in <b>recordSelfBurn</b> on the Verifier.</small>
  </div>

</div>

<script>
/* ------------------------------- helpers -------------------------------- */

const $ = (id) => document.getElementById(id);

function ok(b) { $('libsStatus').textContent = b ? 'libs: OK' : 'libs: failed to load';
                 $('libsStatus').className = 'pill ' + (b ? 'ok' : 'err'); }

function hasLibs() {
  try {
    if (!window.ethers) return false;
    if (!window.buffer || !window.buffer.Buffer) return false;
    if (!window.rlp || typeof window.rlp.encode !== 'function') return false;
    if (!window.ethereumjs_trie || !window.ethereumjs_trie.Trie) return false;
    window.Buffer = window.buffer.Buffer; // expose Node-like Buffer global
    return true;
  } catch { return false; }
}

ok(hasLibs());

function toChecksum(addr) {
  // Normalize to safe checksummed address (fixes “bad address checksum” issues)
  return ethers.utils.getAddress(String(addr).trim().toLowerCase());
}

function namehash(name) {
  // ENS namehash (EIP-137)
  let node = ethers.utils.hexZeroPad('0x00', 32);
  if (!name) return node;
  const labels = name.split('.').reverse();
  for (const l of labels) {
    const lh = ethers.utils.keccak256(ethers.utils.toUtf8Bytes(l));
    node = ethers.utils.keccak256(ethers.utils.concat([node, lh]));
  }
  return node;
}

const qToBuf = (hex) => {
  if (!hex || hex === '0x' || hex === '0x0') return Buffer.from([]);
  let s = hex.slice(2);
  if (s.length % 2) s = '0' + s;
  return Buffer.from(s, 'hex');
};
const toBuf = (hex) => Buffer.from((hex || '0x').slice(2).padStart((((hex||'0x').length-2)%2? (hex.length-1):(hex.length-2)), '0'), 'hex');

function rlpEncodeReceiptPayload(r) {
  // Receipt payload: [status|root, cumulativeGasUsed, logsBloom, logs]
  const statusOrRoot = r.status ? qToBuf(r.status) : toBuf(r.root);
  const cgu = qToBuf(r.cumulativeGasUsed);
  const bloom = toBuf(r.logsBloom);
  const logs = r.logs.map(log => [
    toBuf(log.address),
    log.topics.map(toBuf),
    toBuf(log.data)
  ]);
  return rlp.encode([statusOrRoot, cgu, bloom, logs]);
}

function rlpEncodeTypedReceipt(r) {
  const payload = rlpEncodeReceiptPayload(r);
  const typeHex = (r.type && r.type !== '0x' && r.type !== '0x0') ? r.type : null;
  if (typeHex) {
    const t = parseInt(typeHex, 16);
    return Buffer.concat([Buffer.from([t]), payload]);
  }
  return payload; // legacy
}
function rlpEncodeUint(n) {
  // RLP encode a JS number (tx index)
  const hex = ethers.utils.hexlify(n);
  return rlp.encode(Buffer.from(ethers.utils.stripZeros(hex).slice(2) || '', 'hex'));
}

function rlpEncodeHeader(block) {
  const fields = [];
  fields.push(toBuf(block.parentHash));
  fields.push(toBuf(block.sha3Uncles));
  fields.push(toBuf(block.miner));
  fields.push(toBuf(block.stateRoot));
  fields.push(toBuf(block.transactionsRoot));
  fields.push(toBuf(block.receiptsRoot));
  fields.push(toBuf(block.logsBloom));
  fields.push(qToBuf(block.difficulty));     // 0 in PoS
  fields.push(qToBuf(block.number));
  fields.push(qToBuf(block.gasLimit));
  fields.push(qToBuf(block.gasUsed));
  fields.push(qToBuf(block.timestamp));
  fields.push(toBuf(block.extraData));
  fields.push(toBuf(block.mixHash));         // prevRandao in PoS
  fields.push(toBuf(block.nonce));           // 0x0000000000000000 in PoS
  if (block.baseFeePerGas) fields.push(qToBuf(block.baseFeePerGas));
  if (block.withdrawalsRoot) fields.push(toBuf(block.withdrawalsRoot));
  if (block.blobGasUsed) fields.push(qToBuf(block.blobGasUsed));
  if (block.excessBlobGas) fields.push(qToBuf(block.excessBlobGas));
  if (block.parentBeaconBlockRoot) fields.push(toBuf(block.parentBeaconBlockRoot));
  return rlp.encode(fields);
}

/* ------------------------------- app state ------------------------------- */

let provider, signer, account, net;
const ERC20_ABI = [
  "function decimals() view returns (uint8)",
  "function burn(uint256 amount) returns (bool)",
  "function transfer(address to, uint256 amount) returns (bool)",
];

/* ------------------------------ connect UI ------------------------------ */

$('btnConnect').onclick = async () => {
  try {
    if (!$('rpc').value) {
      if (!window.ethereum) return alert('Please install MetaMask.');
      await window.ethereum.request({ method: 'eth_requestAccounts' });
      provider = new ethers.providers.Web3Provider(window.ethereum);
    } else {
      provider = new ethers.providers.JsonRpcProvider($('rpc').value.trim());
    }
    signer = provider.getSigner();
    account = await signer.getAddress().catch(() => null);
    net = await provider.getNetwork();
    $('acctBox').textContent = `Account: ${account || '(read-only)'}`;
    $('netBox').textContent = `Network: ${net.name} (chainId=${net.chainId})`;

    // Precompute parentNode
    const dn = $('parentDomain').value.trim();
    $('parentNode').value = namehash(dn);
  } catch (e) {
    console.error(e);
    alert('Failed to connect: ' + (e?.message || e));
  }
};

$('parentDomain').addEventListener('input', () => {
  $('parentNode').value = namehash($('parentDomain').value.trim());
});

/* --------------------------------- burn --------------------------------- */

async function detectDecimals(tokenAddr) {
  try {
    const c = new ethers.Contract(tokenAddr, ERC20_ABI, provider);
    const d = await c.decimals();
    return Number(d || 18);
  } catch { return 18; }
}

function parseAmountTokens(txt, decimals) {
  const clean = String(txt).trim();
  return ethers.utils.parseUnits(clean, decimals);
}

let lastTxHash=null;

$('btnBurn').onclick = async () => {
  try {
    if (!provider) return alert('Connect MetaMask first.');
    const tokenAddr = toChecksum($('token').value);
    $('token').value = tokenAddr; // normalize field

    const decimals = await detectDecimals(tokenAddr);
    const amt = parseAmountTokens($('amount').value || '250', decimals);

    const mode = $('burnMode').value;
    const token = new ethers.Contract(tokenAddr, ERC20_ABI, signer);

    let tx;
    if (mode === 'burn') {
      // Try burn(uint256)
      tx = await token.burn(amt);
    } else {
      // fallback: transfer(0x0, amount)
      const ZERO = '0x0000000000000000000000000000000000000000';
      tx = await token.transfer(ZERO, amt);
    }

    $('buildMsg').textContent = 'Submitted burn tx: ' + tx.hash;
    $('txHash').value = tx.hash;
    lastTxHash = tx.hash;
    await watchConfirmations(tx.hash);
  } catch (e) {
    console.error(e);
    alert(e?.message || e);
  }
};

$('btnOpenTx').onclick = () => {
  const h = $('txHash').value.trim();
  if (!h) return;
  window.open(`https://etherscan.io/tx/${h}`, '_blank');
};

async function watchConfirmations(hash) {
  const required = parseInt($('confs').value || '6', 10);
  const r = await provider.getTransactionReceipt(hash);
  if (!r || !r.blockNumber) {
    $('age').textContent = 'Waiting: pending…';
    return;
  }
  const now = await provider.getBlockNumber();
  const confs = now - r.blockNumber + 1; // include mined block
  $('age').innerHTML = confs >= required
    ? `<span class="ok">OK</span>: ${confs} confirmations`
    : `Waiting: ${confs}/${required} confirmations`;
  if (confs >= required && $('autoBuild').checked) {
    await buildProofForTx(hash);
  }
}

/* ------------------------------- build proof ---------------------------- */

$('btnBuild').onclick = async () => {
  const h = $('txHash').value.trim();
  if (!h) return alert('Enter burn tx hash first.');
  await buildProofForTx(h);
};

async function buildProofForTx(txHash) {
  try {
    $('buildMsg').textContent = 'Fetching receipt…';
    const r = await provider.getTransactionReceipt(txHash);
    if (!r || !r.blockNumber) throw new Error('Receipt not found / still pending.');

    const required = parseInt($('confs').value || '6', 10);
    const tip = await provider.getBlockNumber();
    const confs = (tip - r.blockNumber + 1);
    if (confs < required) throw new Error('Not enough confirmations yet');

    // Display basics
    $('blockNumber').value = String(r.blockNumber);
    $('txIndex').value = String(r.transactionIndex);

    $('buildMsg').textContent = 'Downloading block + receipts & building receipts trie…';

    // Pull the full block with transactions
    const block = await provider.send('eth_getBlockByNumber', [ethers.utils.hexValue(r.blockNumber), true]);

    // Get all receipts for the block
    let receipts = null;
    try { receipts = await provider.send('eth_getBlockReceipts', [ethers.utils.hexValue(r.blockNumber)]); } catch{}
    if (!receipts) {
      receipts = [];
      for (const tx of block.transactions) {
        const rr = await provider.getTransactionReceipt(tx.hash);
        receipts.push(rr);
      }
    }

    // Encode and build receipts trie
    const { Trie, createProof } = window.ethereumjs_trie;
    const trie = new Trie();
    for (const rc of receipts) {
      const key = rlpEncodeUint(parseInt(rc.transactionIndex));
      const val = rlpEncodeTypedReceipt(rc);
      await trie.put(key, val);
    }

    const rootHex = '0x' + Buffer.from(trie.root()).toString('hex');
    if (rootHex.toLowerCase() !== block.receiptsRoot.toLowerCase()) {
      throw new Error('Reconstructed receiptsRoot does not match block.receiptsRoot');
    }

    // Header RLP
    const headerRlp = rlpEncodeHeader(block);
    const headerHash = ethers.utils.keccak256(headerRlp);
    if (headerHash.toLowerCase() !== block.hash.toLowerCase()) {
      throw new Error('Header RLP does not hash to block.hash (RPC mismatch).');
    }

    const key = rlpEncodeUint(parseInt(r.transactionIndex));
    const proofArr = await createProof(trie, key);
    const proofRlp = rlp.encode(proofArr);
    const receiptRlp = rlpEncodeTypedReceipt(r);

    $('headerRlp').value  = '0x' + Buffer.from(headerRlp).toString('hex');
    $('receiptRlp').value = '0x' + Buffer.from(receiptRlp).toString('hex');
    $('proofNodes').value = '0x' + Buffer.from(proofRlp).toString('hex');

    $('buildMsg').textContent = 'Proof ready. Paste these bytes in recordSelfBurn on Etherscan.';
  } catch (e) {
    console.error(e);
    $('buildMsg').textContent = 'Error: ' + (e?.message || e);
  }
}

/* ----------------------------- initialize ------------------------------- */

window.addEventListener('load', () => {
  // Set initial parentNode
  $('parentNode').value = namehash($('parentDomain').value.trim());

  // If the hash field changes (user pasted), start polling status
  $('txHash').addEventListener('input', () => {
    const h = $('txHash').value.trim();
    if (h) watchConfirmations(h);
  });

  // Periodically refresh confirmations if we have a tx
  setInterval(() => {
    const h = $('txHash').value.trim() || lastTxHash;
    if (h && provider) watchConfirmations(h);
  }, 5000);
});
</script>
</body>
</html>

