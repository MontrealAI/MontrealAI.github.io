<!doctype html>
<html>
<head>
  <meta charset="utf-8"/>
  <title>Burn → Proof → recordSelfBurn helper</title>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <!-- Minimal CSS -->
  <style>
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; margin: 24px; max-width: 900px }
    h1 { font-size: 20px; margin: 0 0 8px }
    h2 { font-size: 16px; margin-top: 24px }
    label { display:block; margin: 8px 0 4px; font-weight:600 }
    input, select, textarea, button { width: 100%; padding: 8px; font-size: 14px; }
    textarea { height: 120px; font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace }
    .row { display: grid; grid-template-columns: 1fr 1fr; gap: 16px; }
    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; word-break: break-all }
    .ok { color: #0a7a0a; font-weight: 600 }
    .warn { color: #b35600; font-weight: 600 }
    .err { color: #b00020; font-weight: 600 }
    small { color:#555 }
    .card { border: 1px solid #ddd; padding: 12px; border-radius: 8px; margin: 12px 0; }
  </style>
  <!-- Ethers, RLP, Buffer polyfill, EthereumJS Trie -->
  <script src="https://cdn.jsdelivr.net/npm/ethers@5.7.2/dist/ethers.umd.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/buffer@6.0.3/index.min.js"></script>
  <script>window.Buffer = buffer.Buffer;</script>
  <script src="https://cdn.jsdelivr.net/npm/rlp@3.0.0/dist/rlp.umd.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@ethereumjs/util@9.0.1/dist/index.umd.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@ethereumjs/trie@5.6.3/dist/index.umd.js"></script>
</head>
<body>
  <h1>Buyer self‑burn → build proof → recordSelfBurn → claim</h1>

  <div class="card">
    <button id="btnConnect">Connect MetaMask</button>
    <div>Account: <span id="acct" class="mono"></span></div>
    <div>Network: <span id="net" class="mono"></span></div>
  </div>

  <div class="card">
    <h2>1) Configure</h2>
    <label>Parent domain (e.g., <i>example.eth</i>)</label>
    <input id="parentDomain" placeholder="example.eth">
    <div>parentNode (namehash): <span id="parentNode" class="mono"></span></div>

    <label>Label you want to register (e.g., <i>alice</i>)</label>
    <input id="label" placeholder="alice">

    <label>Burn TX hash (after you burned AGI)</label>
    <input id="txHash" placeholder="0x...">

    <div class="row">
      <div>
        <label>Registrar (ForeverSubdomainRegistrar)</label>
        <input id="registrar" value="0x75EA7a1E35F8438557Ee1B6682bdFAfBefcD7637">
      </div>
      <div>
        <label>Verifier (BurnReceiptVerifier)</label>
        <input id="verifier" value="0xBcf1065521A7379D6f4AbEF2dEdAf86a77E5eac8">
      </div>
    </div>
    <div class="row">
      <div>
        <label>RPC URL (optional, must support eth_getBlockByNumber & receipts)</label>
        <input id="rpc" placeholder="(leave blank to use MetaMask)">
      </div>
      <div>
        <label>Confirmations required</label>
        <input id="confs" value="6">
      </div>
    </div>
    <div>Burn age / status: <span id="status" class="mono"></span></div>
  </div>

  <div class="card">
    <h2>2) Build Proof</h2>
    <button id="btnBuild">Build header & receipt proof</button>
    <div id="buildMsg" class="mono"></div>
    <div class="row">
      <div>
        <label>blockNumber (uint256)</label>
        <input id="blockNumber" class="mono" readonly>
      </div>
      <div>
        <label>txIndex (uint256)</label>
        <input id="txIndex" class="mono" readonly>
      </div>
    </div>
    <label>headerRlp (bytes)</label>
    <textarea id="headerRlp" readonly></textarea>

    <label>receiptRlp (bytes)</label>
    <textarea id="receiptRlp" readonly></textarea>

    <label>rlpParentNodes (bytes)</label>
    <textarea id="proofNodes" readonly></textarea>

    <small>Paste these three bytes values + buyer + parentNode + label + blockNumber + txIndex into <b>recordSelfBurn</b> on the verifier.</small>
  </div>

  <div class="card">
    <h2>3) Call contracts on Etherscan</h2>
    <ol>
      <li>Open <b>BurnReceiptVerifier</b> at <code class="mono">0xBcf1065521A7379D6f4AbEF2dEdAf86a77E5eac8</code> → Contract → Write as Proxy.</li>
      <li>Call <b>recordSelfBurn</b> with:
        <ul>
          <li><b>buyer</b> = your wallet address</li>
          <li><b>parentNode</b> = value shown above</li>
          <li><b>label</b> = same label you will register</li>
          <li><b>blockNumber</b>, <b>txIndex</b> (shown above)</li>
          <li><b>headerRlp</b>, <b>receiptRlp</b>, <b>rlpParentNodes</b> (copy from above)</li>
        </ul>
      </li>
      <li>Then open <b>ForeverSubdomainRegistrar</b> at <code class="mono">0x75EA7a1E35F8438557Ee1B6682bdFAfBefcD7637</code> → Write as Proxy → call <b>claimAfterSelfBurn(name, newOwner, duration)</b>.</li>
    </ol>
  </div>

<script>
(async () => {
  const { RLP } = window.rlp;
  const { Trie, createProof } = window.ethereumjs_trie;
  const { bytesToHex, hexToBytes } = window.ethereumjs_util;

  const $ = id => document.getElementById(id);
  let provider, signer, acct, net;

  $('btnConnect').onclick = async () => {
    if ($('rpc').value) {
      provider = new ethers.providers.JsonRpcProvider($('rpc').value);
    } else {
      if (!window.ethereum) return alert('Install MetaMask');
      await window.ethereum.request({ method: 'eth_requestAccounts' });
      provider = new ethers.providers.Web3Provider(window.ethereum);
    }
    signer = provider.getSigner();
    acct = await signer.getAddress().catch(()=>null);
    const network = await provider.getNetwork();
    $('acct').textContent = acct || '(read-only)';
    $('net').textContent = `${network.name} (${network.chainId})`;
  };

  // ENS namehash (EIP-137)
  function namehash(name) {
    let node = new Uint8Array(32); // zero hash
    if (name) {
      const labels = name.split('.').reverse();
      for (const l of labels) {
        const labelHash = ethers.utils.keccak256(ethers.utils.toUtf8Bytes(l));
        node = hexToBytes(ethers.utils.keccak256(ethers.utils.concat([node, hexToBytes(labelHash)])));
      }
    }
    return '0x' + Buffer.from(node).toString('hex');
  }

  // RLP helpers
  const toBuf = (hex) => Buffer.from((hex || '0x').slice(2).padStart(((hex||'0x').length-2 + ( ( (hex||'0x').length-2)%2 ?1:0)), '0'), 'hex');
  const qToBuf = (hex) => { // hex quantity -> minimal big-endian
    if (!hex || hex === '0x' || hex === '0x0') return Buffer.from([]);
    let s = hex.slice(2);
    if (s.length % 2) s = '0' + s;
    return Buffer.from(s, 'hex');
  };

  function rlpEncodeReceiptPayload(r) {
    // Receipt payload: [status|root, cumulativeGasUsed, logsBloom, logs]
    const statusOrRoot = r.status ? qToBuf(r.status) : toBuf(r.root);
    const cgu = qToBuf(r.cumulativeGasUsed);
    const bloom = toBuf(r.logsBloom);
    const logs = r.logs.map(log => [
      toBuf(log.address),
      log.topics.map(toBuf),
      toBuf(log.data)
    ]);
    return RLP.encode([ statusOrRoot, cgu, bloom, logs ]);
  }

  function rlpEncodeTypedReceipt(r) {
    const payload = rlpEncodeReceiptPayload(r);
    const typeHex = (r.type && r.type !== '0x' && r.type !== '0x0') ? r.type : null;
    if (typeHex) {
      const t = parseInt(typeHex, 16);
      return Buffer.concat([ Buffer.from([t]), payload ]);
    }
    return payload; // legacy-style, untyped
  }

  function rlpEncodeHeader(block) {
    // Execution header fields (order matters)
    const fields = [];
    fields.push(toBuf(block.parentHash));
    fields.push(toBuf(block.sha3Uncles));
    fields.push(toBuf(block.miner));
    fields.push(toBuf(block.stateRoot));
    fields.push(toBuf(block.transactionsRoot));
    fields.push(toBuf(block.receiptsRoot));
    fields.push(toBuf(block.logsBloom));
    fields.push(qToBuf(block.difficulty)); // 0 in PoS
    fields.push(qToBuf(block.number));
    fields.push(qToBuf(block.gasLimit));
    fields.push(qToBuf(block.gasUsed));
    fields.push(qToBuf(block.timestamp));
    fields.push(toBuf(block.extraData));
    fields.push(toBuf(block.mixHash));     // prevRandao in PoS
    fields.push(toBuf(block.nonce));       // 0x0000000000000000 in PoS
    if (block.baseFeePerGas) fields.push(qToBuf(block.baseFeePerGas));
    if (block.withdrawalsRoot) fields.push(toBuf(block.withdrawalsRoot));
    if (block.blobGasUsed) fields.push(qToBuf(block.blobGasUsed));
    if (block.excessBlobGas) fields.push(qToBuf(block.excessBlobGas));
    if (block.parentBeaconBlockRoot) fields.push(toBuf(block.parentBeaconBlockRoot));
    return RLP.encode(fields);
  }

  function hex(num) { return '0x' + BigInt(num).toString(16); }

  async function getBlockAndAllReceipts(blockNumberHex) {
    // Get block with tx objects
    const block = await provider.send('eth_getBlockByNumber', [blockNumberHex, true]);
    // Try batch receipts if supported
    let receipts = null;
    try {
      // Some nodes support 'eth_getBlockReceipts'
      receipts = await provider.send('eth_getBlockReceipts', [blockNumberHex]);
    } catch (_) {}
    if (!receipts) {
      // Fallback: fetch each receipt
      receipts = [];
      for (const tx of block.transactions) {
        const r = await provider.getTransactionReceipt(tx.hash);
        receipts.push(r);
      }
    }
    return { block, receipts };
  }

  function rlpEncodeUint(n) {
    // n is Number
    return RLP.encode(Buffer.from(ethers.utils.stripZeros(ethers.utils.hexlify(n)).slice(2) || '', 'hex'));
  }

  async function buildProof() {
    const txHash = $('txHash').value.trim();
    const parent = $('parentDomain').value.trim();
    const confsRequired = parseInt($('confs').value || '6', 10);

    if (!txHash) return alert('Enter burn TX hash');
    if (!parent) return alert('Enter parent domain');

    // parentNode
    const pnode = namehash(parent);
    $('parentNode').textContent = pnode;

    const r = await provider.getTransactionReceipt(txHash);
    if (!r || !r.blockNumber) throw new Error('Receipt not found / pending');
    const blockNum = r.blockNumber;
    const now = await provider.getBlockNumber();
    const confs = now - blockNum;
    $('status').textContent = confs >= confsRequired
      ? `OK: ${confs} confirmations` : `Waiting: ${confs}/${confsRequired} confirmations`;

    if (confs < confsRequired) throw new Error('Not enough confirmations yet');
    if (confs > 256) throw new Error('Too old for blockhash (must be ≤ 256 blocks)');

    $('blockNumber').value = String(blockNum);
    $('txIndex').value = String(r.transactionIndex);

    // Load block + all receipts to rebuild receipts trie
    $('buildMsg').textContent = 'Downloading block + receipts and building trie... (can take a moment)';
    const { block, receipts } = await getBlockAndAllReceipts(ethers.utils.hexValue(blockNum));

    // headerRlp and sanity check against block.hash
    const headerRlp = rlpEncodeHeader(block);
    const headerHash = ethers.utils.keccak256(headerRlp);
    if (headerHash.toLowerCase() !== block.hash.toLowerCase()) {
      throw new Error('Header RLP does not hash to block.hash (RPC mismatch).');
    }

    // Build receipts trie
    const trie = new Trie(); // in-memory
    for (const rc of receipts) {
      const key = rlpEncodeUint(parseInt(rc.transactionIndex));
      const val = rlpEncodeTypedReceipt(rc);
      await trie.put(key, val);
    }
    const rootHex = '0x' + Buffer.from(trie.root()).toString('hex');
    if (rootHex.toLowerCase() !== block.receiptsRoot.toLowerCase()) {
      throw new Error('Reconstructed receiptsRoot does not match block.receiptsRoot');
    }

    // Proof for our txIndex
    const key = rlpEncodeUint(parseInt(r.transactionIndex));
    const proofArr = await createProof(trie, key); // array of RLP-encoded nodes (Buffers)
    const proofRlp = RLP.encode(proofArr);

    // Encoded receipt (typed)
    const receiptRlp = rlpEncodeTypedReceipt(r);

    // Fill outputs
    $('headerRlp').value = '0x' + Buffer.from(headerRlp).toString('hex');
    $('receiptRlp').value = '0x' + Buffer.from(receiptRlp).toString('hex');
    $('proofNodes').value = '0x' + Buffer.from(proofRlp).toString('hex');

    $('buildMsg').textContent = 'Proof ready. Paste into recordSelfBurn on Etherscan.';
  }

  $('btnBuild').onclick = () => buildProof().catch(e => {
    console.error(e); $('buildMsg').textContent = 'Error: ' + (e && e.message || e);
  });
})();
</script>
</body>
</html>

