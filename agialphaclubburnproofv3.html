<!doctype html>
<html>
<head>
  <meta charset="utf-8"/>
  <title>Burn → Proof → recordSelfBurn helper</title>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>

  <!-- Minimal CSS -->
  <style>
    :root { --muted:#555; --ok:#0a7a0a; --warn:#b35600; --err:#b00020; }
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; margin: 24px; max-width: 980px }
    h1 { font-size: 20px; margin: 0 0 8px }
    h2 { font-size: 16px; margin-top: 24px }
    label { display:block; margin: 8px 0 6px; font-weight:600 }
    input, select, textarea, button { width: 100%; padding: 10px; font-size: 14px; }
    textarea { height: 130px; font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace }
    .row { display: grid; grid-template-columns: 1fr 1fr; gap: 16px; }
    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; word-break: break-all }
    .ok { color: var(--ok); font-weight: 600 }
    .warn { color: var(--warn); font-weight: 600 }
    .err { color: var(--err); font-weight: 600 }
    small { color:var(--muted) }
    .card { border: 1px solid #ddd; padding: 12px; border-radius: 8px; margin: 12px 0; }
    .actions { display:flex; gap:8px; flex-wrap:wrap; }
    .pill { display:inline-block; padding:4px 8px; border:1px solid #ddd; border-radius:999px; font-size:12px; background:#fafafa }
    a { color:#0366d6; text-decoration:none }
    a:hover { text-decoration:underline }
  </style>

  <!-- Libraries (UMD) -->
  <script defer src="https://cdn.jsdelivr.net/npm/ethers@5.7.2/dist/ethers.umd.min.js"></script>
  <script defer src="https://cdn.jsdelivr.net/npm/@ethereumjs/rlp@4.0.1/dist/rlp.umd.min.js"></script>
  <script defer src="https://cdn.jsdelivr.net/npm/@ethereumjs/util@9.0.1/dist/index.umd.js"></script>
  <script defer src="https://cdn.jsdelivr.net/npm/@ethereumjs/trie@5.6.3/dist/index.umd.js"></script>
</head>
<body>
  <h1>Buyer self‑burn → build proof → <code>recordSelfBurn</code> → claim</h1>

  <div class="card">
    <div class="actions">
      <button id="btnConnect">Connect MetaMask</button>
      <span id="libStatus" class="pill">libs: checking…</span>
    </div>
    <div>Account: <span id="acct" class="mono"></span></div>
    <div>Network: <span id="net" class="mono"></span></div>
  </div>

  <div class="card">
    <h2>1) Configure</h2>
    <label>Parent domain (e.g., <i>example.eth</i>)</label>
    <input id="parentDomain" placeholder="example.eth" />

    <div>parentNode (namehash): <span id="parentNode" class="mono"></span></div>

    <label>Label you want to register (e.g., <i>alice</i>)</label>
    <input id="label" placeholder="alice" />

    <label>Burn TX hash (after you burned AGI)</label>
    <input id="txHash" placeholder="0x…" />

    <div class="row">
      <div>
        <label>Registrar (ForeverSubdomainRegistrar)</label>
        <input id="registrar" value="0x75EA7a1E35F8438557Ee1B6682bdFAfBefcD7637">
      </div>
      <div>
        <label>Verifier (BurnReceiptVerifier)</label>
        <input id="verifier" value="0xBcf1065521A7379D6f4AbEF2dEdAf86a77E5eac8">
      </div>
    </div>

    <div class="row">
      <div>
        <label>RPC URL (optional, else MetaMask is used)</label>
        <input id="rpc" placeholder="(leave blank to use MetaMask)">
      </div>
      <div>
        <label>Confirmations required</label>
        <input id="confs" value="6">
      </div>
    </div>

    <div>Burn age / status: <span id="status" class="mono"></span></div>

    <div class="actions" style="margin-top:8px">
      <a id="linkVerifier" class="pill" target="_blank" rel="noopener">Open Verifier on Etherscan</a>
      <a id="linkRegistrar" class="pill" target="_blank" rel="noopener">Open Registrar on Etherscan</a>
    </div>
  </div>

  <div class="card">
    <h2>2) Build Proof</h2>
    <button id="btnBuild">Build header & receipt proof</button>
    <div id="buildMsg" class="mono" style="margin-top:8px"></div>

    <div class="row" style="margin-top:12px">
      <div>
        <label>blockNumber (uint256)</label>
        <input id="blockNumber" class="mono" readonly>
      </div>
      <div>
        <label>txIndex (uint256)</label>
        <input id="txIndex" class="mono" readonly>
      </div>
    </div>

    <label>headerRlp (bytes)</label>
    <textarea id="headerRlp" readonly></textarea>

    <label>receiptRlp (bytes)</label>
    <textarea id="receiptRlp" readonly></textarea>

    <label>rlpParentNodes (bytes)</label>
    <textarea id="proofNodes" readonly></textarea>

    <small>
      Paste these 3 byte strings plus <b>buyer</b> (your wallet), <b>parentNode</b> (above),
      <b>label</b>, <b>blockNumber</b>, and <b>txIndex</b> into <b>recordSelfBurn</b> on the Verifier.
    </small>
  </div>

  <div class="card">
    <h2>3) Submit on Etherscan (no code needed)</h2>
    <ol>
      <li>
        Open <b>BurnReceiptVerifier</b> at
        <code class="mono">0xBcf1065521A7379D6f4AbEF2dEdAf86a77E5eac8</code>
        → <b>Contract</b> → <b>Write as Proxy</b> → method <b>recordSelfBurn</b>.
        Fill in:
        <ul>
          <li><b>buyer</b> — your wallet address (shown after Connect).</li>
          <li><b>parentNode</b> — from the top section.</li>
          <li><b>label</b> — same label you plan to claim (exact lowercase).</li>
          <li><b>blockNumber</b>, <b>txIndex</b> — values from section 2.</li>
          <li><b>headerRlp</b>, <b>receiptRlp</b>, <b>rlpParentNodes</b> — copy all text from section 2.</li>
        </ul>
        Send the transaction.
      </li>
      <li style="margin-top:8px">
        When that’s confirmed, open <b>ForeverSubdomainRegistrar</b> at
        <code class="mono">0x75EA7a1E35F8438557Ee1B6682bdFAfBefcD7637</code>
        → <b>Write as Proxy</b> → method <b>claimAfterSelfBurn(name, newOwner, duration)</b>.
        Use <b>name</b> as <code>label.parent</code> (e.g. <code>alice.example.eth</code>),
        <b>newOwner</b> = your wallet, and <b>duration</b> in seconds (e.g. one year = <code>31536000</code>).
      </li>
    </ol>
  </div>

<script>
window.addEventListener('DOMContentLoaded', () => {
  const $ = id => document.getElementById(id);

  // ---- Library readiness check ------------------------------------------------
  const need = () => (window.ethers && window.rlp && window.ethereumjs_util && window.ethereumjs_trie);
  const markLibs = ok => {
    $('libStatus').textContent = ok ? 'libs: ready' : 'libs: failed to load';
    $('libStatus').style.borderColor = ok ? '#8bc34a' : '#f44336';
    $('libStatus').style.background = ok ? '#f6fff6' : '#fff6f6';
  };
  let tries = 0;
  const waitLibs = setInterval(() => {
    tries++;
    if (need()) { clearInterval(waitLibs); markLibs(true); }
    else if (tries > 60) { clearInterval(waitLibs); markLibs(false); }
  }, 100);

  // Shortcuts from ethereumjs/util
  const u = () => window.ethereumjs_util || {};
  const toBytes = (hex) => {
    if (!hex || hex === '0x') return new Uint8Array([]);
    return u().hexToBytes(hex);
  };
  const bytesToHex = (bytes) => u().bytesToHex(bytes);

  // Minimal big‑endian quantity -> bytes (no leading zeros)
  const qToBytes = (value) => {
    // value can be number | string | BigNumber | hex string
    const hex = ethers.utils.stripZeros(ethers.utils.hexlify(value));
    return toBytes(hex);
  };

  // RLP helpers using @ethereumjs/rlp
  const RLP = () => window.rlp;

  // concat Uint8Arrays
  const concat = (...arrays) => {
    const len = arrays.reduce((n, a) => n + a.length, 0);
    const out = new Uint8Array(len);
    let o = 0;
    for (const a of arrays) { out.set(a, o); o += a.length; }
    return out;
  };

  // Encode a receipt payload (EIP‑658+ typed receipts supported)
  function rlpEncodeReceiptPayload(r) {
    const statusOrRoot = (r.status !== null && r.status !== undefined)
      ? qToBytes(r.status)
      : toBytes(r.root || '0x');

    const cgu = qToBytes(r.cumulativeGasUsed);
    const bloom = toBytes(r.logsBloom);

    const logs = r.logs.map(log => [
      toBytes(log.address),
      log.topics.map(toBytes),
      toBytes(log.data)
    ]);

    return RLP().encode([ statusOrRoot, cgu, bloom, logs ]);
  }

  function rlpEncodeTypedReceipt(r) {
    const payload = rlpEncodeReceiptPayload(r);

    // ethers v5 gives a number (0,1,2,...). Some RPCs return hex. Handle both.
    let typeNum = 0;
    if (r.type !== undefined && r.type !== null) {
      typeNum = (typeof r.type === 'number') ? r.type : parseInt(String(r.type), 16);
    }
    if (typeNum) {
      return concat(new Uint8Array([typeNum]), payload);
    }
    return payload; // legacy
  }

  // Header RLP (execution header). Optional fields only if present.
  function rlpEncodeHeader(block) {
    const fields = [];
    fields.push(toBytes(block.parentHash));
    fields.push(toBytes(block.sha3Uncles));
    fields.push(toBytes(block.miner));
    fields.push(toBytes(block.stateRoot));
    fields.push(toBytes(block.transactionsRoot));
    fields.push(toBytes(block.receiptsRoot));
    fields.push(toBytes(block.logsBloom));
    fields.push(qToBytes(block.difficulty));       // 0 in PoS
    fields.push(qToBytes(block.number));
    fields.push(qToBytes(block.gasLimit));
    fields.push(qToBytes(block.gasUsed));
    fields.push(qToBytes(block.timestamp));
    fields.push(toBytes(block.extraData));
    fields.push(toBytes(block.mixHash));           // prevRandao in PoS
    fields.push(toBytes(block.nonce));             // 0x0000000000000000 in PoS
    if (block.baseFeePerGas)        fields.push(qToBytes(block.baseFeePerGas));
    if (block.withdrawalsRoot)      fields.push(toBytes(block.withdrawalsRoot));
    if (block.blobGasUsed)          fields.push(qToBytes(block.blobGasUsed));
    if (block.excessBlobGas)        fields.push(qToBytes(block.excessBlobGas));
    if (block.parentBeaconBlockRoot)fields.push(toBytes(block.parentBeaconBlockRoot));
    return RLP().encode(fields);
  }

  async function getBlockAndAllReceipts(provider, blockNumber) {
    const blockHex = ethers.utils.hexValue(blockNumber);
    const block = await provider.send('eth_getBlockByNumber', [blockHex, true]);
    if (!block) throw new Error('Block not found from RPC');

    // Try fast path
    let receipts = null;
    try {
      receipts = await provider.send('eth_getBlockReceipts', [blockHex]);
    } catch (_) {}
    if (!receipts) {
      receipts = [];
      for (const tx of block.transactions) {
        receipts.push(await provider.getTransactionReceipt(tx.hash));
      }
    }
    return { block, receipts };
  }

  // ---- UI wiring & MetaMask connect ------------------------------------------
  let provider, signer, account;

  function setLinks() {
    const v = $('verifier').value.trim();
    const r = $('registrar').value.trim();
    $('linkVerifier').href  = `https://etherscan.io/address/${v}#writeProxyContract`;
    $('linkRegistrar').href = `https://etherscan.io/address/${r}#writeProxyContract`;
  }
  setLinks();
  $('verifier').addEventListener('input', setLinks);
  $('registrar').addEventListener('input', setLinks);

  $('btnConnect').onclick = async () => {
    try {
      if ($('rpc').value.trim()) {
        provider = new ethers.providers.JsonRpcProvider($('rpc').value.trim());
      } else {
        if (!window.ethereum) {
          alert('MetaMask not found. Install the extension and refresh.');
          return;
        }
        await window.ethereum.request({ method: 'eth_requestAccounts' });
        provider = new ethers.providers.Web3Provider(window.ethereum);
      }
      signer = provider.getSigner();
      account = await signer.getAddress().catch(() => null);
      const { name, chainId } = await provider.getNetwork();

      $('acct').textContent = account || '(read‑only)';
      $('net').textContent = `${name} (chainId=${chainId})`;
    } catch (e) {
      console.error(e);
      alert('Failed to connect: ' + (e?.message || e));
    }
  };

  // ENS namehash (use ethers’ built‑in)
  function computeParentNode() {
    const parent = $('parentDomain').value.trim();
    const node = parent ? ethers.utils.namehash(parent) : '0x' + '00'.repeat(32);
    $('parentNode').textContent = node;
    return node;
  }
  $('parentDomain').addEventListener('input', computeParentNode);

  async function buildProof() {
    try {
      $('buildMsg').className = 'mono';
      $('buildMsg').textContent = 'Starting…';

      if (!provider) {
        $('buildMsg').classList.add('warn');
        $('buildMsg').textContent = 'Not connected — click “Connect MetaMask” (or provide RPC URL).';
        return;
      }

      const txHash = $('txHash').value.trim();
      const parent = $('parentDomain').value.trim();
      const requiredConfs = parseInt(($('confs').value || '6').trim(), 10);

      if (!txHash) throw new Error('Enter burn TX hash');
      if (!parent) throw new Error('Enter parent domain');

      const parentNode = computeParentNode();

      // Get burn receipt
      const receipt = await provider.getTransactionReceipt(txHash);
      if (!receipt || !receipt.blockNumber) throw new Error('Receipt not found or still pending');

      const latest = await provider.getBlockNumber();
      const confs = latest - receipt.blockNumber;

      $('status').textContent = confs >= requiredConfs
        ? `OK: ${confs} confirmations`
        : `Waiting: ${confs}/${requiredConfs} confirmations`;

      if (confs < requiredConfs) throw new Error('Not enough confirmations yet');
      if (confs > 256) throw new Error('Too old for on-chain blockhash (must be ≤ 256 blocks)');

      $('buildMsg').textContent = 'Downloading block + receipts…';

      // Rebuild receipts trie and header
      const { block, receipts } = await getBlockAndAllReceipts(provider, receipt.blockNumber);

      const headerRlp = rlpEncodeHeader(block);
      const headerHash = ethers.utils.keccak256(headerRlp);
      if (headerHash.toLowerCase() !== block.hash.toLowerCase()) {
        throw new Error('Header RLP does not hash to block.hash (RPC mismatch).');
      }

      // Build receipts trie and proof
      const { Trie, createProof } = window.ethereumjs_trie;
      const trie = new Trie();
      for (const rc of receipts) {
        const key = RLP().encode(qToBytes(rc.transactionIndex)); // key is RLP(txIndex)
        const val = rlpEncodeTypedReceipt(rc);
        await trie.put(key, val);
      }

      const rootHex = bytesToHex(trie.root());
      if (rootHex.toLowerCase() !== String(block.receiptsRoot).toLowerCase()) {
        throw new Error('Reconstructed receiptsRoot does not match block.receiptsRoot');
      }

      // Create proof for our txIndex
      const key = RLP().encode(qToBytes(receipt.transactionIndex));
      const nodes = await createProof(trie, key);          // array of node Uint8Arrays
      const proofRlp = RLP().encode(nodes);                // RLP(list of nodes)
      const receiptRlp = rlpEncodeTypedReceipt(receipt);   // typed receipt

      // Fill outputs
      $('blockNumber').value = String(receipt.blockNumber);
      $('txIndex').value     = String(receipt.transactionIndex);
      $('headerRlp').value   = bytesToHex(headerRlp);
      $('receiptRlp').value  = bytesToHex(receiptRlp);
      $('proofNodes').value  = bytesToHex(proofRlp);

      $('buildMsg').classList.add('ok');
      $('buildMsg').textContent = 'Proof ready. Paste into recordSelfBurn on Etherscan.';
    } catch (e) {
      console.error(e);
      $('buildMsg').className = 'mono err';
      $('buildMsg').textContent = 'Error: ' + (e?.message || e);
    }
  }

  $('btnBuild').onclick = buildProof;
});
</script>
</body>
</html>

