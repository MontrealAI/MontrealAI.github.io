<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <title>Buyer self‑burn → build proof → recordSelfBurn → claim</title>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <style>
    :root { --bg:#fff; --fg:#111; --muted:#666; --accent:#111; --ok:#0a7a0a; --warn:#b35600; --err:#b00020; --bd:#ddd; }
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; margin: 24px; max-width: 980px; color:var(--fg); background:var(--bg); }
    h1 { font-size: 20px; margin:0 0 8px }
    h2 { font-size: 16px; margin:20px 0 8px }
    label { display:block; margin: 8px 0 4px; font-weight:600 }
    input, select, textarea, button { width: 100%; padding: 8px; font-size: 14px; }
    textarea { height: 120px; font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace }
    .row { display:grid; grid-template-columns: 1fr 1fr; gap: 16px; }
    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; word-break: break-all }
    .card { border:1px solid var(--bd); padding:12px; border-radius:8px; margin:12px 0 }
    .ok { color:var(--ok); font-weight:600 }
    .warn { color:var(--warn); font-weight:600 }
    .err { color:var(--err); font-weight:600 }
    .btn { background:#111; color:#fff; border:0; border-radius:8px; cursor:pointer; padding:10px 12px; font-weight:600 }
    .btn:disabled { opacity:.6; cursor:not-allowed }
    .line { display:flex; gap:12px; align-items:center; justify-content:space-between }
    small { color:var(--muted) }
    code { background:#f5f5f5; padding:2px 4px; border-radius:4px }
  </style>
</head>
<body>
<h1>Buyer self‑burn → build proof → <span class="mono">recordSelfBurn</span> → claim</h1>

<div class="card">
  <div class="line">
    <button id="btnConnect" class="btn">Connect MetaMask</button>
    <div id="libStatus" class="warn mono">libs: loading…</div>
  </div>
  <div>Account: <span id="acct" class="mono"></span></div>
  <div>Network: <span id="net" class="mono"></span></div>
</div>

<div class="card">
  <h2>1) Configure</h2>
  <label>Parent domain (e.g., <i>example.eth</i>)</label>
  <input id="parentDomain" placeholder="example.eth" value="alpha.club.agi.eth">
  <div>parentNode (namehash): <span id="parentNode" class="mono"></span></div>

  <label>Label you want to register (e.g., <i>alice</i>)</label>
  <input id="label" placeholder="alice" value="3">

  <div class="row">
    <div>
      <label>Registrar (ForeverSubdomainRegistrar)</label>
      <input id="registrar" value="0x75EA7a1E35F8438557Ee1B6682bdFAfBefcD7637">
    </div>
    <div>
      <label>Verifier (BurnReceiptVerifier)</label>
      <input id="verifier" value="0xBcf1065521A7379D6f4AbEF2dEdAf86a77E5eac8">
    </div>
  </div>

  <div class="row">
    <div>
      <label>AGI token address</label>
      <input id="token" value="0xf0780f43b86c13b3d0681b1cf6daeb1499e7f14d">
      <small>Lower‑case or checksummed is fine; we’ll normalize.</small>
    </div>
    <div>
      <label>Burn to</label>
      <select id="burnTo">
        <option value="tokenBurn">Real burn (call token.burn)</option>
        <option value="zero">0x0000…0000 (recommended fallback)</option>
        <option value="dead">0x0000…dEaD</option>
      </select>
      <small>If the token lacks <code>burn(uint256)</code>, fallback uses <code>transfer(..., amount)</code>.</small>
    </div>
  </div>

  <div class="row">
    <div>
      <label>Amount to burn</label>
      <input id="amount" value="250">
      <small>AGI / decimals auto‑detected (fallback 18).</small>
    </div>
    <div>
      <label>Confirmations required</label>
      <input id="confs" value="6">
    </div>
  </div>

  <div class="row">
    <div>
      <label>RPC URL (optional; leave blank to use MetaMask)</label>
      <input id="rpc" placeholder="(must support eth_getBlockByNumber & receipts)">
    </div>
    <div>
      <label>Burn age / status</label>
      <div id="status" class="mono"></div>
    </div>
  </div>

  <div class="row">
    <button id="btnBurn" class="btn">Burn 250 AGI</button>
    <button id="btnOpenTx" class="btn" style="background:#333">Open burn tx on Etherscan</button>
  </div>

  <label>Burn TX hash (auto‑filled after “Burn now”, or paste manually)</label>
  <input id="txHash" class="mono" placeholder="0x… (transaction hash)">
</div>

<div class="card">
  <h2>2) Build proof</h2>
  <div class="line">
    <button id="btnBuild" class="btn">Build header & receipt proof</button>
    <label style="display:flex;gap:8px;align-items:center">
      <input id="autoBuild" type="checkbox" checked> Auto‑build when ready
    </label>
  </div>
  <div id="buildMsg" class="mono warn"></div>
  <div class="row">
    <div>
      <label>blockNumber (uint256)</label>
      <input id="blockNumber" class="mono" readonly>
    </div>
    <div>
      <label>txIndex (uint256)</label>
      <input id="txIndex" class="mono" readonly>
    </div>
  </div>

  <label>headerRlp (bytes)</label>
  <textarea id="headerRlp" class="mono" readonly></textarea>

  <label>receiptRlp (bytes)</label>
  <textarea id="receiptRlp" class="mono" readonly></textarea>

  <label>rlpParentNodes (bytes)</label>
  <textarea id="proofNodes" class="mono" readonly></textarea>

  <small>Copy the three bytes values above and use them (with <b>buyer</b>, <b>parentNode</b>, <b>label</b>, <b>blockNumber</b>, <b>txIndex</b>) in <b>recordSelfBurn</b> on the Verifier.</small>
</div>

<script type="module">
/* ---- ESM imports (switch to local files after you download them; see instructions below) ---- */
import { ethers } from 'https://esm.sh/ethers@5.7.2?bundle';
import { RLP }     from 'https://esm.sh/@ethereumjs/rlp@4.0.1?bundle';
import { Trie }    from 'https://esm.sh/@ethereumjs/trie@5.6.3?bundle';

/* ---- UI helpers ---- */
const $ = id => document.getElementById(id);
const sleep = (ms)=>new Promise(r=>setTimeout(r,ms));

let provider, signer, acct, net;

/* check libs */
(function() {
  const ok = !!ethers && !!RLP && !!Trie;
  $('libStatus').textContent = ok ? 'libs: ok' : 'libs: failed to load';
  $('libStatus').className = ok ? 'ok mono' : 'err mono';
})();

/* connect */
$('btnConnect').onclick = async () => {
  try {
    if ($('rpc').value) {
      provider = new ethers.providers.JsonRpcProvider($('rpc').value);
    } else {
      if (!window.ethereum) return alert('Install MetaMask');
      await window.ethereum.request({ method: 'eth_requestAccounts' });
      provider = new ethers.providers.Web3Provider(window.ethereum);
    }
    signer = provider.getSigner();
    acct = await signer.getAddress().catch(()=>null);
    net = await provider.getNetwork();
    $('acct').textContent = acct || '(read‑only)';
    $('net').textContent = `${net.name} (chainId=${net.chainId})`;
    computeParentNode();
    pollStatus(); // start polling burn status if a txHash is present
  } catch (e) {
    alert((e && e.message) || String(e));
  }
};

function computeParentNode() {
  try {
    const name = $('parentDomain').value.trim();
    const node = ethers.utils.namehash(name);
    $('parentNode').textContent = node;
  } catch {
    $('parentNode').textContent = '—';
  }
}
$('parentDomain').addEventListener('input', computeParentNode);

/* utils */
const hexlify = ethers.utils.hexlify;
const arrayify = ethers.utils.arrayify;
const concat = ethers.utils.concat;
const keccak256 = ethers.utils.keccak256;
const toUtf8Bytes = ethers.utils.toUtf8Bytes;

function okAddr(s) {
  if (!s) throw new Error('empty address');
  try { return ethers.utils.getAddress(s); }
  catch(_) { return ethers.utils.getAddress(s.toLowerCase()); }
}
function toBytes(hex) {
  if (!hex || hex === '0x') return new Uint8Array([]);
  return arrayify(hex);
}
function qToBytes(hexQty) { // 0x‑prefixed quantity to minimal bytes
  if (!hexQty || hexQty === '0x' || hexQty === '0x0') return new Uint8Array([]);
  return arrayify(hexQty);
}
function encodeUint(n) { // RLP of a JS number (txIndex)
  const h = ethers.utils.hexlify(n);
  return RLP.encode(arrayify(h === '0x00' ? '0x' : h));
}

/* ERC‑20 ABI (tiny) */
const ERC20 = [
  'function decimals() view returns (uint8)',
  'function burn(uint256 amount)',
  'function transfer(address to, uint256 amount) returns (bool)',
  'function balanceOf(address) view returns (uint256)'
];

/* burn helper */
$('btnBurn').onclick = async () => {
  try {
    if (!signer) return alert('Connect MetaMask first');
    const tokenAddr = okAddr($('token').value.trim());
    const wants = $('burnTo').value; // tokenBurn | zero | dead
    const token = new ethers.Contract(tokenAddr, ERC20, signer);

    // decimals
    let dec = 18;
    try { dec = await token.decimals(); } catch {}
    const amt = ethers.utils.parseUnits(($('amount').value || '0').trim(), dec);

    let tx;
    if (wants === 'tokenBurn') {
      tx = await token.burn(amt); // will throw if method not present
    } else {
      const to =
        wants === 'zero'
          ? '0x0000000000000000000000000000000000000000'
          : '0x000000000000000000000000000000000000dEaD';
      tx = await token.transfer(to, amt);
    }
    $('txHash').value = tx.hash;
    $('btnOpenTx').onclick = () => window.open(`https://etherscan.io/tx/${tx.hash}`, '_blank');
    $('status').textContent = 'Submitted. Waiting for confirmations…';
    pollStatus();
  } catch (e) {
    alert(e.message || String(e));
  }
};

/* live status + autobuild */
async function pollStatus() {
  if (!provider) return;
  const need = parseInt($('confs').value || '6', 10);
  while (true) {
    const h = $('txHash').value.trim();
    if (!h) { $('status').textContent = ''; return; }
    let r;
    try { r = await provider.getTransactionReceipt(h); } catch {}
    if (!r || !r.blockNumber) { $('status').textContent = 'Pending…'; await sleep(3500); continue; }
    $('blockNumber').value = String(r.blockNumber);
    $('txIndex').value = String(r.transactionIndex);
    const now = await provider.getBlockNumber();
    const confs = Math.max(0, now - r.blockNumber);
    $('status').textContent = confs >= need ? `OK: ${confs} confirmations` : `Waiting: ${confs}/${need} confirmations`;
    if (confs >= need) {
      if ($('autoBuild').checked) {
        try { await buildProofFromTx(h); } catch(e) { $('buildMsg').textContent = 'Error: ' + (e.message || e); }
      }
      return;
    }
    await sleep(3500);
  }
}

/* Build proof */
$('btnBuild').onclick = () => buildProofFromTx($('txHash').value.trim()).catch(e=>{
  $('buildMsg').textContent = 'Error: ' + (e.message || e);
});

async function getBlockAndReceipts(blockNumberHex) {
  const block = await provider.send('eth_getBlockByNumber', [blockNumberHex, true]);
  let receipts = null;
  try { receipts = await provider.send('eth_getBlockReceipts', [blockNumberHex]); } catch {}
  if (!receipts) {
    receipts = [];
    for (const tx of block.transactions) {
      receipts.push(await provider.getTransactionReceipt(tx.hash));
    }
  }
  return { block, receipts };
}

function rlpEncodeReceiptPayload(r) {
  // [status|root, cumulativeGasUsed, logsBloom, logs]
  const statusOrRoot = (r.status !== null && r.status !== undefined) ? qToBytes(ethers.utils.hexlify(r.status)) : toBytes(r.root);
  const cgu = qToBytes(r.cumulativeGasUsed);
  const bloom = toBytes(r.logsBloom);
  const logs = r.logs.map(log => [ toBytes(log.address), log.topics.map(toBytes), toBytes(log.data) ]);
  return RLP.encode([ statusOrRoot, cgu, bloom, logs ]);
}
function rlpEncodeTypedReceipt(r) {
  const payload = rlpEncodeReceiptPayload(r);
  const typeHex = r.type && r.type !== '0x' && r.type !== '0x0' ? r.type : null;
  if (typeHex) {
    const t = Number(typeHex); // 0x0..0x2
    return concat([ new Uint8Array([t]), payload ]);
  }
  return payload;
}
function rlpEncodeHeader(block) {
  const F = [];
  F.push(toBytes(block.parentHash));
  F.push(toBytes(block.sha3Uncles));
  F.push(toBytes(block.miner));
  F.push(toBytes(block.stateRoot));
  F.push(toBytes(block.transactionsRoot));
  F.push(toBytes(block.receiptsRoot));
  F.push(toBytes(block.logsBloom));
  F.push(qToBytes(block.difficulty || '0x0'));
  F.push(qToBytes(block.number));
  F.push(qToBytes(block.gasLimit));
  F.push(qToBytes(block.gasUsed));
  F.push(qToBytes(block.timestamp));
  F.push(toBytes(block.extraData));
  F.push(toBytes(block.mixHash));   // prevRandao in PoS
  F.push(toBytes(block.nonce));     // PoS keeps 0x000...
  if (block.baseFeePerGas)    F.push(qToBytes(block.baseFeePerGas));
  if (block.withdrawalsRoot)  F.push(toBytes(block.withdrawalsRoot));
  if (block.blobGasUsed)      F.push(qToBytes(block.blobGasUsed));
  if (block.excessBlobGas)    F.push(qToBytes(block.excessBlobGas));
  if (block.parentBeaconBlockRoot) F.push(toBytes(block.parentBeaconBlockRoot));
  return RLP.encode(F);
}

async function buildProofFromTx(txHash) {
  if (!txHash) throw new Error('Enter/paste a burn transaction hash first');
  $('buildMsg').textContent = 'Preparing…';
  const need = parseInt($('confs').value || '6', 10);

  const rc = await provider.getTransactionReceipt(txHash);
  if (!rc || !rc.blockNumber) throw new Error('Receipt not found / pending');
  const now = await provider.getBlockNumber();
  const confs = Math.max(0, now - rc.blockNumber);
  if (confs < need) throw new Error('Not enough confirmations yet');

  $('blockNumber').value = String(rc.blockNumber);
  $('txIndex').value = String(rc.transactionIndex);

  $('buildMsg').textContent = 'Downloading block + receipts…';
  const { block, receipts } = await getBlockAndReceipts(ethers.utils.hexValue(rc.blockNumber));

  // header
  const headerRlp = rlpEncodeHeader(block);
  const headerHash = keccak256(headerRlp);
  if (headerHash.toLowerCase() !== String(block.hash).toLowerCase()) {
    throw new Error('Header RLP does not hash to block.hash (RPC mismatch)');
  }

  $('buildMsg').textContent = 'Rebuilding receipts trie…';
  const trie = new Trie();
  for (const r of receipts) {
    const key = encodeUint(Number(r.transactionIndex));
    const val = rlpEncodeTypedReceipt(r);
    await trie.put(key, val);
  }
  const rootHex = hexlify(trie.root());
  if (rootHex.toLowerCase() !== String(block.receiptsRoot).toLowerCase()) {
    throw new Error('Reconstructed receiptsRoot does not match block.receiptsRoot');
  }

  // proof
  const key = encodeUint(Number(rc.transactionIndex));
  let proofArr;
  // try both APIs (version differences)
  if (typeof trie.createProof === 'function') {
    proofArr = await trie.createProof(key);
  } else if (Trie.createProof) {
    proofArr = await Trie.createProof(trie, key);
  } else {
    throw new Error('createProof not found on Trie (version mismatch)');
  }
  const proofRlp = RLP.encode(proofArr);
  const receiptRlp = rlpEncodeTypedReceipt(rc);

  $('headerRlp').value  = hexlify(headerRlp);
  $('receiptRlp').value = hexlify(receiptRlp);
  $('proofNodes').value = hexlify(proofRlp);
  $('buildMsg').textContent = 'Proof ready. Paste into recordSelfBurn on Etherscan.';
}
</script>

<!--
SELF‑HOST INSTRUCTIONS
1) Make a local folder "libs" beside this HTML.
2) Download the three ESM bundles (each is a single self‑contained file):

   curl -L -o libs/ethers-5.7.2.bundle.js  https://esm.sh/ethers@5.7.2?bundle
   curl -L -o libs/rlp-4.0.1.bundle.js     https://esm.sh/@ethereumjs/rlp@4.0.1?bundle
   curl -L -o libs/trie-5.6.3.bundle.js    https://esm.sh/@ethereumjs/trie@5.6.3?bundle

3) Replace the three import lines at the top with:

   import { ethers } from './libs/ethers-5.7.2.bundle.js';
   import { RLP }     from './libs/rlp-4.0.1.bundle.js';
   import { Trie }    from './libs/trie-5.6.3.bundle.js';

That’s it. No Buffer shim needed (we use @ethereumjs/rlp@4 which works on Uint8Array).
-->
</body>
</html>

