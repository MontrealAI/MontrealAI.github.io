<!doctype html>
<html>
<head>
  <meta charset="utf-8"/>
  <title>AGI Burn → Proof → recordSelfBurn helper</title>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>

  <style>
    :root { --fg:#111; --muted:#555; --ok:#117a2a; --warn:#b35600; --err:#b00020; --line:#e5e5e5; --bg:#fff; }
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; margin: 24px; max-width: 980px; color:var(--fg); background:var(--bg) }
    h1 { font-size: 20px; margin: 0 0 12px }
    h2 { font-size: 16px; margin: 20px 0 8px }
    label { display:block; margin: 10px 0 6px; font-weight:600 }
    input, select, textarea, button { width: 100%; padding: 10px; font-size: 14px; border: 1px solid var(--line); border-radius: 8px; }
    textarea { height: 120px; font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace }
    .row { display: grid; grid-template-columns: 1fr 1fr; gap: 14px; }
    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; word-break: break-all }
    .ok { color: var(--ok); font-weight: 600 }
    .warn { color: var(--warn); font-weight: 600 }
    .err { color: var(--err); font-weight: 600 }
    small { color:var(--muted) }
    .card { border: 1px solid var(--line); padding: 14px; border-radius: 12px; margin: 14px 0; }
    .btn { cursor: pointer; background:#111; color:#fff; border:none; font-weight:600 }
    .btn:disabled { opacity: .6; cursor:not-allowed }
    .pill { padding: 8px 10px; border-radius: 999px; border:1px solid var(--line); display:inline-block; }
    .toolbar { display:flex; gap:10px; align-items:center }
    .muted { color:var(--muted) }
  </style>

  <!-- Correct UMD bundles + Buffer polyfill -->
  <script src="https://cdn.jsdelivr.net/npm/ethers@5.7.2/dist/ethers.umd.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/buffer@6.0.3/index.min.js"></script>
  <script>window.Buffer = buffer.Buffer;</script>
  <script src="https://cdn.jsdelivr.net/npm/@ethereumjs/rlp@4.0.1/dist/index.umd.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@ethereumjs/util@9.0.1/dist/index.umd.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@ethereumjs/trie@5.6.3/dist/index.umd.min.js"></script>
</head>
<body>
  <h1>Buyer self‑burn → build proof → <span class="mono">recordSelfBurn</span> → claim</h1>

  <div class="card">
    <div class="toolbar">
      <button id="btnConnect" class="btn" style="width:220px">Connect MetaMask</button>
      <span id="libs" class="pill muted">libs: loading…</span>
      <span class="muted">|</span>
      <span>Account: <span id="acct" class="mono muted">(not connected)</span></span>
      <span>Network: <span id="net" class="mono muted">—</span></span>
    </div>
  </div>

  <div class="card">
    <h2>1) Configure</h2>

    <label>Parent domain (e.g., <i>example.eth</i>)</label>
    <input id="parentDomain" placeholder="alpha.club.agi.eth">
    <div class="muted">parentNode (namehash): <span id="parentNode" class="mono">—</span></div>

    <label>Label you want to register (e.g., <i>alice</i>)</label>
    <input id="label" placeholder="alice">

    <div class="row">
      <div>
        <label>Registrar (ForeverSubdomainRegistrar)</label>
        <input id="registrar" value="0x75EA7a1E35F8438557Ee1B6682bdFAfBefcD7637">
      </div>
      <div>
        <label>Verifier (BurnReceiptVerifier)</label>
        <input id="verifier" value="0xBcf1065521A7379D6f4AbEF2dEdAf86a77E5eac8">
      </div>
    </div>

    <div class="row">
      <div>
        <label>AGI token address</label>
        <input id="token" value="0xf0780f43b86c13b3d0681b1cf6daeb1499e7f14d">
        <small>AGI / decimals assumed 18 if unreadable</small>
      </div>
      <div>
        <label>Burn to</label>
        <select id="burnTo">
          <option value="burn">Real burn (call token.burn)</option>
          <option value="dead">Lock forever at 0x…dEaD (fallback)</option>
        </select>
        <small id="burnToNote" class="muted">Real burn tries <span class="mono">burn(uint256)</span>; fallback uses <span class="mono">transfer(0x…dEaD,amount)</span>.</small>
      </div>
    </div>

    <div class="row">
      <div>
        <label>Amount to burn</label>
        <input id="amount" value="250">
        <small>AGI / decimals 18 (we’ll multiply by 10^decimals)</small>
      </div>
      <div>
        <label>Confirmations required</label>
        <input id="confs" value="6">
      </div>
    </div>

    <div class="row">
      <div>
        <label>RPC URL (optional; leave blank to use MetaMask)</label>
        <input id="rpc" placeholder="(must support eth_getBlockReceipts or receipts by hash)">
      </div>
      <div>
        <label>Burn age / status</label>
        <textarea id="status" readonly>—</textarea>
      </div>
    </div>

    <div class="row">
      <button id="btnBurn" class="btn" style="width:100%">Burn 250 AGI</button>
      <a id="btnOpenTx" class="btn" style="text-align:center; text-decoration:none; display:inline-block" href="#" target="_blank">Open burn tx on Etherscan</a>
    </div>

    <label>Burn TX hash (auto‑filled after “Burn now”, or paste manually)</label>
    <input id="txHash" placeholder="0x…">
  </div>

  <div class="card">
    <h2>2) Build proof</h2>
    <button id="btnBuild" class="btn" style="width:100%">Build header & receipt proof</button>
    <div id="buildMsg" class="mono muted" style="margin-top:8px">—</div>

    <div class="row" style="margin-top:10px">
      <div>
        <label>blockNumber (uint256)</label>
        <input id="blockNumber" class="mono" readonly>
      </div>
      <div>
        <label>txIndex (uint256)</label>
        <input id="txIndex" class="mono" readonly>
      </div>
    </div>

    <label>headerRlp (bytes)</label>
    <textarea id="headerRlp" readonly></textarea>

    <label>receiptRlp (bytes)</label>
    <textarea id="receiptRlp" readonly></textarea>

    <label>rlpParentNodes (bytes)</label>
    <textarea id="proofNodes" readonly></textarea>

    <small>Copy these three bytes values, and use with <b>buyer</b> (your wallet), <b>parentNode</b>, <b>label</b>, <b>blockNumber</b>, <b>txIndex</b> in <b>recordSelfBurn</b> on the Verifier.</small>
  </div>

  <div class="card">
    <h2>3) Call contracts on Etherscan</h2>
    <ol>
      <li>Open <b>BurnReceiptVerifier</b> at <code class="mono">0xBcf1065521A7379D6f4AbEF2dEdAf86a77E5eac8</code> → <b>Contract</b> → <b>Write as Proxy</b> → connect wallet.</li>
      <li>Call <b>recordSelfBurn</b> with:
        <ul>
          <li><b>buyer</b> = your wallet address shown at top</li>
          <li><b>parentNode</b> = value shown above</li>
          <li><b>label</b> = the label you’re registering</li>
          <li><b>blockNumber</b>, <b>txIndex</b> (from step 2)</li>
          <li><b>headerRlp</b>, <b>receiptRlp</b>, <b>rlpParentNodes</b> (from step 2)</li>
        </ul>
      </li>
      <li>Then open <b>ForeverSubdomainRegistrar</b> at <code class="mono">0x75EA7a1E35F8438557Ee1B6682bdFAfBefcD7637</code> → <b>Write as Proxy</b> → call <b>claimAfterSelfBurn(name, newOwner, duration)</b>.</li>
    </ol>
  </div>

<script>
(() => {
  // --- Quick lib sanity ---
  const libsEl = document.getElementById('libs');
  function libsOk() {
    const ok = window.ethers && window.Buffer && window.ethereumjs_rlp && window.ethereumjs_util && window.ethereumjs_trie;
    libsEl.textContent = ok ? 'libs: loaded ✓' : 'libs: failed to load';
    libsEl.className = 'pill ' + (ok ? 'ok' : 'err');
  }
  libsOk();

  const { RLP } = window.ethereumjs_rlp || {};
  const { Trie, createProof } = window.ethereumjs_trie || {};
  const { hexToBytes } = window.ethereumjs_util || {};

  const $ = id => document.getElementById(id);
  let provider, signer, acct, net;

  const ERC20_ABI = [
    'function decimals() view returns (uint8)',
    'function transfer(address to, uint256 value) returns (bool)',
    'function burn(uint256 value)',                      // may or may not exist
    'event Transfer(address indexed from, address indexed to, uint256 value)'
  ];

  // ENS namehash (EIP-137)
  function namehash(name) {
    let node = new Uint8Array(32); // zero hash
    if (name && name.trim() !== '') {
      const labels = name.split('.').reverse();
      for (const l of labels) {
        const labelHash = ethers.utils.keccak256(ethers.utils.toUtf8Bytes(l));
        node = hexToBytes(ethers.utils.keccak256(ethers.utils.concat([node, hexToBytes(labelHash)])));
      }
    }
    return '0x' + Buffer.from(node).toString('hex');
  }

  // helpers
  const toBuf = (hex) => Buffer.from((hex || '0x').slice(2).padStart(((hex||'0x').length-2 + (((hex||'0x').length-2)%2 ?1:0)), '0'), 'hex');
  const qToBuf = (hex) => { if (!hex || hex === '0x' || hex === '0x0') return Buffer.from([]); let s = hex.slice(2); if (s.length % 2) s = '0' + s; return Buffer.from(s, 'hex'); };
  function rlpEncodeReceiptPayload(r) {
    const statusOrRoot = r.status ? qToBuf(r.status) : toBuf(r.root);
    const cgu = qToBuf(r.cumulativeGasUsed);
    const bloom = toBuf(r.logsBloom);
    const logs = r.logs.map(log => [ toBuf(log.address), log.topics.map(toBuf), toBuf(log.data) ]);
    return RLP.encode([ statusOrRoot, cgu, bloom, logs ]);
  }
  function rlpEncodeTypedReceipt(r) {
    const payload = rlpEncodeReceiptPayload(r);
    const typeHex = (r.type && r.type !== '0x' && r.type !== '0x0') ? r.type : null;
    if (typeHex) return Buffer.concat([ Buffer.from([parseInt(typeHex, 16)]), payload ]);
    return payload;
  }
  function rlpEncodeHeader(block) {
    const fields = [];
    fields.push(toBuf(block.parentHash));
    fields.push(toBuf(block.sha3Uncles));
    fields.push(toBuf(block.miner));
    fields.push(toBuf(block.stateRoot));
    fields.push(toBuf(block.transactionsRoot));
    fields.push(toBuf(block.receiptsRoot));
    fields.push(toBuf(block.logsBloom));
    fields.push(qToBuf(block.difficulty));
    fields.push(qToBuf(block.number));
    fields.push(qToBuf(block.gasLimit));
    fields.push(qToBuf(block.gasUsed));
    fields.push(qToBuf(block.timestamp));
    fields.push(toBuf(block.extraData));
    fields.push(toBuf(block.mixHash));     // prevRandao
    fields.push(toBuf(block.nonce));       // 0x00..00 in PoS
    if (block.baseFeePerGas) fields.push(qToBuf(block.baseFeePerGas));
    if (block.withdrawalsRoot) fields.push(toBuf(block.withdrawalsRoot));
    if (block.blobGasUsed) fields.push(qToBuf(block.blobGasUsed));
    if (block.excessBlobGas) fields.push(qToBuf(block.excessBlobGas));
    if (block.parentBeaconBlockRoot) fields.push(toBuf(block.parentBeaconBlockRoot));
    return RLP.encode(fields);
  }
  function rlpEncodeUint(n) {
    return RLP.encode(Buffer.from(ethers.utils.stripZeros(ethers.utils.hexlify(n)).slice(2) || '', 'hex'));
  }

  // UI wiring
  $('btnConnect').onclick = async () => {
    try {
      const rpc = $('rpc').value.trim();
      if (rpc) {
        provider = new ethers.providers.JsonRpcProvider(rpc);
      } else {
        if (!window.ethereum) return alert('Please install MetaMask');
        await window.ethereum.request({ method: 'eth_requestAccounts' });
        provider = new ethers.providers.Web3Provider(window.ethereum, 'any');
      }
      signer = provider.getSigner();
      acct = await signer.getAddress().catch(()=>null);
      const network = await provider.getNetwork();
      $('acct').textContent = acct || '(read-only)';
      $('net').textContent = `${network.name} (chainId=${network.chainId})`;
    } catch (e) {
      console.error(e);
      alert('Could not connect: ' + (e && e.message || e));
    }
  };

  // keep parentNode updated
  $('parentDomain').addEventListener('input', () => {
    const v = $('parentDomain').value.trim();
    if (!v || v.includes('..')) { $('parentNode').textContent = '—'; return; }
    try { $('parentNode').textContent = namehash(v); } catch { $('parentNode').textContent = '—'; }
  });

  // Burn flow (prefers token.burn, fallback to transfer 0x…dEaD)
  $('btnBurn').onclick = async () => {
    try {
      if (!provider) return alert('Connect MetaMask first');
      const tokenInput = $('token').value.trim();
      // tolerate any case by normalizing to checksum; if it throws, try lowercase
      let tokenAddr;
      try { tokenAddr = ethers.utils.getAddress(tokenInput); }
      catch { tokenAddr = ethers.utils.getAddress(tokenInput.toLowerCase()); }

      const token = new ethers.Contract(tokenAddr, ERC20_ABI, signer);
      const decimals = (await token.decimals().catch(()=>18)) || 18;

      const amtHuman = $('amount').value.trim() || '250';
      const amt = ethers.utils.parseUnits(amtHuman, decimals); // 250 * 10^18

      const mode = $('burnTo').value; // 'burn' | 'dead'
      let tx;

      if (mode === 'burn') {
        // try token.burn
        try {
          await token.estimateGas.burn(amt);
        } catch (e) {
          $('status').value = 'Token.burn not available or not permitted. Falling back to 0x…dEaD transfer.\n' +
                              'NOTE: If your verifier requires address(0), this fallback will NOT pass recordSelfBurn.';
          $('burnTo').value = 'dead';
        }
      }

      if ($('burnTo').value === 'burn') {
        tx = await token.burn(amt);
      } else {
        const DEAD = '0x000000000000000000000000000000000000dEaD';
        await token.estimateGas.transfer(DEAD, amt); // will throw if token blocks it
        tx = await token.transfer(DEAD, amt);
      }

      $('status').value = `Submitted burn tx: ${tx.hash}\nWaiting for confirmations…`;
      $('btnOpenTx').href = `https://etherscan.io/tx/${tx.hash}`;
      $('btnOpenTx').textContent = 'Open burn tx on Etherscan';
      $('txHash').value = tx.hash;

      const confsReq = parseInt(($('confs').value || '6'), 10);
      const rcpt = await tx.wait(confsReq);
      $('status').value = `OK: ${confsReq} confirmations\nblock=${rcpt.blockNumber}, txIndex=${rcpt.transactionIndex}`;
      // After enough confirmations, build proof automatically
      await buildProofFromTx(tx.hash);
    } catch (e) {
      console.error(e);
      $('status').value = (e && e.message) ? e.message : String(e);
      alert('Burn failed: ' + (e && e.message || e));
    }
  };

  $('btnBuild').onclick = async () => {
    const h = $('txHash').value.trim();
    if (!h) return alert('Paste a burn tx hash first');
    await buildProofFromTx(h).catch(e => {
      console.error(e); $('buildMsg').textContent = 'Error: ' + (e && e.message || e);
    });
  };

  async function getBlockAndAllReceipts(blockNumberHex) {
    const block = await provider.send('eth_getBlockByNumber', [blockNumberHex, true]);
    let receipts = null;
    try { receipts = await provider.send('eth_getBlockReceipts', [blockNumberHex]); } catch (_) {}
    if (!receipts) {
      receipts = [];
      for (const tx of block.transactions) {
        receipts.push(await provider.getTransactionReceipt(tx.hash));
      }
    }
    return { block, receipts };
  }

  async function buildProofFromTx(txHash) {
    $('buildMsg').textContent = 'Fetching receipt…';
    const r = await provider.getTransactionReceipt(txHash);
    if (!r || !r.blockNumber) throw new Error('Receipt not found / pending');
    $('blockNumber').value = String(r.blockNumber);
    $('txIndex').value = String(r.transactionIndex);

    const confsReq = parseInt(($('confs').value || '6'), 10);
    const tip = await provider.getBlockNumber();
    const have = tip - r.blockNumber;
    $('status').value = have >= confsReq
      ? `OK: ${have} confirmations`
      : `Waiting: ${have}/${confsReq} confirmations`;
    if (have < confsReq) throw new Error('Not enough confirmations yet');
    if (have > 256) throw new Error('Too old for blockhash-based checks (must be ≤ 256 blocks)');

    $('buildMsg').textContent = 'Downloading block & receipts and rebuilding receipts trie…';
    const { block, receipts } = await getBlockAndAllReceipts(ethers.utils.hexValue(r.blockNumber));

    const headerRlp = rlpEncodeHeader(block);
    const headerHash = ethers.utils.keccak256(headerRlp);
    if (headerHash.toLowerCase() !== block.hash.toLowerCase()) {
      throw new Error('Header RLP does not hash to block.hash (RPC mismatch).');
    }

    const trie = new Trie();
    for (const rc of receipts) {
      const key = rlpEncodeUint(parseInt(rc.transactionIndex));
      const val = rlpEncodeTypedReceipt(rc);
      await trie.put(key, val);
    }
    const rootHex = '0x' + Buffer.from(trie.root()).toString('hex');
    if (rootHex.toLowerCase() !== block.receiptsRoot.toLowerCase()) {
      throw new Error('Reconstructed receiptsRoot does not match block.receiptsRoot');
    }

    const key = rlpEncodeUint(parseInt(r.transactionIndex));
    const proofArr = await createProof(trie, key);
    const proofRlp = RLP.encode(proofArr);
    const receiptRlp = rlpEncodeTypedReceipt(r);

    $('headerRlp').value = '0x' + Buffer.from(headerRlp).toString('hex');
    $('receiptRlp').value = '0x' + Buffer.from(receiptRlp).toString('hex');
    $('proofNodes').value = '0x' + Buffer.from(proofRlp).toString('hex');
    $('buildMsg').textContent = 'Proof ready. Paste into recordSelfBurn on the Verifier.';
  }
})();
</script>
</body>
</html>

